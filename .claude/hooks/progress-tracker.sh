#!/bin/bash
# progress-tracker.sh - PostToolUse Hook for Ralph v2.41
# Auto-registro de intentos/errores en .claude/progress.md por proyecto
#
# Input (JSON via stdin):
#   - hook_event_name: "PostToolUse"
#   - tool_name: Name of tool that was used
#   - tool_input: Tool input parameters
#   - tool_result: Result of tool execution
#   - session_id: Current session identifier
#
# Output (JSON):
#   - continue: true (always continue, this is logging only)
#
# Part of Ralph v2.41 Context Engineering - progress.md system
# Based on: docs/yt/stop-using-ralph-plugin-summary.md

# VERSION: 2.45.3
set -euo pipefail

# Configuration
LOG_FILE="${HOME}/.ralph/logs/progress-tracker.log"
MAX_PROGRESS_ENTRIES=100  # Keep last N entries per project

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true

# Logging function
log() {
    local level="$1"
    shift
    echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] [$level] $*" >> "$LOG_FILE" 2>/dev/null || true
}

# Read input from stdin
INPUT=$(cat)

# Parse input JSON
TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // "unknown"' 2>/dev/null || echo "unknown")
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // "unknown"' 2>/dev/null || echo "unknown")
TOOL_INPUT=$(echo "$INPUT" | jq -r '.tool_input // {}' 2>/dev/null || echo "{}")
TOOL_RESULT=$(echo "$INPUT" | jq -r '.tool_result // {}' 2>/dev/null || echo "{}")
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Only track relevant tools (Edit, Write, Bash)
case "$TOOL_NAME" in
    Edit|Write|Bash)
        log "INFO" "Tracking tool: $TOOL_NAME in session $SESSION_ID"
        ;;
    *)
        # Skip non-relevant tools silently
        echo '{"continue": true}'
        exit 0
        ;;
esac

# Get current working directory (project)
PROJECT_DIR=$(pwd 2>/dev/null || echo "$HOME")
PROGRESS_FILE="${PROJECT_DIR}/.claude/progress.md"

# Ensure .claude directory exists in project
mkdir -p "${PROJECT_DIR}/.claude" 2>/dev/null || true

# Extract relevant info based on tool type
extract_tool_info() {
    case "$TOOL_NAME" in
        Edit)
            FILE_PATH=$(echo "$TOOL_INPUT" | jq -r '.file_path // "unknown"' 2>/dev/null || echo "unknown")
            echo "Edit: $FILE_PATH"
            ;;
        Write)
            FILE_PATH=$(echo "$TOOL_INPUT" | jq -r '.file_path // "unknown"' 2>/dev/null || echo "unknown")
            echo "Write: $FILE_PATH"
            ;;
        Bash)
            COMMAND=$(echo "$TOOL_INPUT" | jq -r '.command // "unknown"' 2>/dev/null | head -c 100)
            echo "Bash: $COMMAND"
            ;;
        *)
            echo "$TOOL_NAME"
            ;;
    esac
}

# Detect if result indicates error
detect_error() {
    local result="$1"

    # Check for common error indicators
    if echo "$result" | grep -qiE '(error|failed|exception|traceback|fatal|panic)'; then
        return 0  # Has error
    fi
    return 1  # No error
}

# Extract error message if present
extract_error_message() {
    local result="$1"

    # Try to extract first error line
    echo "$result" | grep -iE '(error|failed|exception|traceback)' | head -1 | head -c 200
}

# Append entry to progress.md
append_progress_entry() {
    local tool_info="$1"
    local has_error="$2"
    local error_msg="$3"

    # Create header if file doesn't exist
    if [[ ! -f "$PROGRESS_FILE" ]]; then
        cat > "$PROGRESS_FILE" << 'EOF'
# Progress Log

> Auto-generated by progress-tracker.sh (Ralph v2.41)
> Frame de referencia para iteraciones futuras

EOF
    fi

    # Check if we need a new session header
    # Use sed instead of grep -oP for macOS compatibility
    local last_session
    last_session=$(grep 'Sesion:' "$PROGRESS_FILE" 2>/dev/null | tail -1 | sed 's/.*Sesion: //' | tr -d ' ' || echo "")

    if [[ "$last_session" != "$SESSION_ID" ]]; then
        echo "" >> "$PROGRESS_FILE"
        echo "## Sesion: $SESSION_ID" >> "$PROGRESS_FILE"
    fi

    # Append entry
    echo "" >> "$PROGRESS_FILE"
    echo "### $TIMESTAMP" >> "$PROGRESS_FILE"
    echo "- **Herramienta**: $tool_info" >> "$PROGRESS_FILE"

    if [[ "$has_error" == "true" ]]; then
        echo "- **Resultado**: :x: Error" >> "$PROGRESS_FILE"
        if [[ -n "$error_msg" ]]; then
            echo "- **Error**: \`$error_msg\`" >> "$PROGRESS_FILE"
        fi
    else
        echo "- **Resultado**: :white_check_mark: OK" >> "$PROGRESS_FILE"
    fi

    log "INFO" "Progress entry appended: $tool_info (error: $has_error)"
}

# Trim old entries to keep file manageable
trim_progress_file() {
    if [[ -f "$PROGRESS_FILE" ]]; then
        local line_count
        line_count=$(wc -l < "$PROGRESS_FILE")

        # If file is too large, keep only recent entries
        if [[ "$line_count" -gt 500 ]]; then
            # Keep header (first 5 lines) + last 400 lines
            {
                head -5 "$PROGRESS_FILE"
                echo ""
                echo "> (Entries trimmed to last 400 lines)"
                echo ""
                tail -400 "$PROGRESS_FILE"
            } > "${PROGRESS_FILE}.tmp"
            mv "${PROGRESS_FILE}.tmp" "$PROGRESS_FILE"
            log "INFO" "Progress file trimmed from $line_count to ~405 lines"
        fi
    fi
}

# Main execution
main() {
    # Extract tool info
    local tool_info
    tool_info=$(extract_tool_info)

    # Detect errors
    local has_error="false"
    local error_msg=""

    if detect_error "$TOOL_RESULT"; then
        has_error="true"
        error_msg=$(extract_error_message "$TOOL_RESULT")
    fi

    # Append to progress file
    append_progress_entry "$tool_info" "$has_error" "$error_msg"

    # Trim if needed
    trim_progress_file

    log "INFO" "Progress tracking completed for $TOOL_NAME"
}

# Run main
main

# Return success (hook should not block execution)
echo '{"continue": true}'
