# P3 Event-Driven Engine - Implementation Plan v2.51

> **Status**: VALIDATED - Implementable with Phased Barrier Architecture
> **Analysis**: Adversarial validation complete (Opus 4.5)
> **Date**: 2026-01-19

---

## Executive Summary

### User Requirements (from /clarify)

| Requirement | Choice | Implication |
|-------------|--------|-------------|
| **Consistency** | ESTRICTA | Paso N+1 NUNCA inicia hasta que TODOS sub-pasos de N terminen |
| **Failure Handling** | WAIT-ALL | Esperar a que todos terminen antes de reportar error |
| **State Management** | SINGLE-SOURCE | Un archivo plan-state.json con locks (flock) |
| **Timeout Strategy** | GRACEFUL | Permitir que eventos "in flight" terminen ordenadamente |

### Key Insight

> **Events and ordering are orthogonal concerns.**
> - Events = communication mechanism (can arrive out of order)
> - Barriers = ordering guarantee (enforce sequence between phases)
> - Combined: Parallelism WITHIN phases + Sequential ordering BETWEEN phases

---

## Architecture: Phased Barrier Engine

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         PHASED BARRIER ENGINE v2.51                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                           â”‚
â”‚   â”‚  EVENT BUS   â”‚ â†â”€â”€ Events can arrive in ANY order                        â”‚
â”‚   â”‚  (Queue)     â”‚                                                           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                           â”‚
â”‚          â”‚                                                                   â”‚
â”‚          â–¼                                                                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                           â”‚
â”‚   â”‚   PHASE      â”‚ â†â”€â”€ Phases execute SEQUENTIALLY                           â”‚
â”‚   â”‚ COORDINATOR  â”‚     (barrier between each phase)                          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                           â”‚
â”‚          â”‚                                                                   â”‚
â”‚          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚          â–¼                      â–¼                      â–¼                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚   â”‚   STEP A   â”‚         â”‚   STEP B   â”‚         â”‚   STEP C   â”‚ â† PARALLEL   â”‚
â”‚   â”‚  (Agent)   â”‚         â”‚  (Agent)   â”‚         â”‚  (Agent)   â”‚   within     â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   phase      â”‚
â”‚         â”‚                      â”‚                      â”‚                      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                â”‚                                             â”‚
â”‚                                â–¼                                             â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚                      â”‚     BARRIER      â”‚ â†â”€â”€ WAIT-ALL: waits for ALL        â”‚
â”‚                      â”‚  (Sync Point)    â”‚     steps to complete              â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                               â”‚                                              â”‚
â”‚                               â–¼                                              â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚                      â”‚   NEXT PHASE     â”‚                                    â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Implementation Phases

### PHASE 1: Foundations (v2.51.0) - 3-5 days

#### 1.1 Enhanced plan-state.json Schema

**File**: `.claude/plan-state.json`

```json
{
  "version": "2.51.0",
  "plan_id": "uuid",
  "created_at": "ISO8601",
  "phases": [
    {
      "phase_id": "clarify",
      "phase_name": "Clarification",
      "step_ids": ["1"],
      "depends_on": [],
      "execution_mode": "sequential",
      "status": "pending"
    },
    {
      "phase_id": "classify",
      "phase_name": "Classification",
      "step_ids": ["2"],
      "depends_on": ["clarify"],
      "execution_mode": "sequential",
      "status": "pending"
    },
    {
      "phase_id": "implement",
      "phase_name": "Implementation",
      "step_ids": ["6a", "6b", "6c"],
      "depends_on": ["classify"],
      "execution_mode": "parallel",
      "status": "pending"
    },
    {
      "phase_id": "validate",
      "phase_name": "Validation",
      "step_ids": ["7a", "7b", "7c", "7d"],
      "depends_on": ["implement"],
      "execution_mode": "parallel",
      "status": "pending"
    }
  ],
  "steps": {
    "1": { "name": "Clarify", "status": "pending", "result": null },
    "2": { "name": "Classify", "status": "pending", "result": null },
    "6a": { "name": "LSA-Verify", "status": "pending", "result": null },
    "6b": { "name": "Implement", "status": "pending", "result": null },
    "6c": { "name": "Plan-Sync", "status": "pending", "result": null },
    "7a": { "name": "Correctness", "status": "pending", "result": null },
    "7b": { "name": "Quality", "status": "pending", "result": null },
    "7c": { "name": "Consistency", "status": "pending", "result": null },
    "7d": { "name": "Adversarial", "status": "pending", "result": null }
  },
  "current_phase": null,
  "barriers": {
    "clarify_complete": false,
    "classify_complete": false,
    "implement_complete": false,
    "validate_complete": false
  }
}
```

#### 1.2 Barrier Manager

**File**: `~/.claude/scripts/barrier-manager.py`

```python
#!/usr/bin/env python3
"""
Barrier Manager - Phased Barrier Architecture for Ralph v2.51
Ensures STRICT consistency: phase N+1 never starts until ALL sub-steps of N complete.
"""

import json
import fcntl
import os
import sys
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, List

PLAN_STATE_FILE = Path.home() / ".claude" / "plan-state.json"
LOCK_FILE = Path.home() / ".claude" / "plan-state.lock"


class BarrierManager:
    """Manages phase barriers with SINGLE-SOURCE file locking."""

    def __init__(self):
        self.lock_fd = None

    def _acquire_lock(self) -> None:
        """Acquire exclusive lock on plan-state."""
        LOCK_FILE.parent.mkdir(parents=True, exist_ok=True)
        self.lock_fd = open(LOCK_FILE, 'w')
        fcntl.flock(self.lock_fd.fileno(), fcntl.LOCK_EX)

    def _release_lock(self) -> None:
        """Release lock."""
        if self.lock_fd:
            fcntl.flock(self.lock_fd.fileno(), fcntl.LOCK_UN)
            self.lock_fd.close()
            self.lock_fd = None

    def _read_state(self) -> Dict:
        """Read plan state (must hold lock)."""
        if not PLAN_STATE_FILE.exists():
            return {}
        with open(PLAN_STATE_FILE, 'r') as f:
            return json.load(f)

    def _write_state(self, state: Dict) -> None:
        """Write plan state (must hold lock)."""
        PLAN_STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
        with open(PLAN_STATE_FILE, 'w') as f:
            json.dump(state, f, indent=2)

    def complete_step(self, step_id: str, result: str = "success") -> Dict:
        """
        Mark a step as complete and check if barrier can be released.
        Returns: {"barrier_released": bool, "next_phase": str|None}
        """
        try:
            self._acquire_lock()
            state = self._read_state()

            if not state or "steps" not in state:
                return {"error": "No active plan state"}

            # Update step status
            if step_id in state["steps"]:
                state["steps"][step_id]["status"] = "completed"
                state["steps"][step_id]["result"] = result
                state["steps"][step_id]["completed_at"] = datetime.now().isoformat()

            # Find current phase and check if all steps complete
            current_phase = state.get("current_phase")
            barrier_released = False
            next_phase = None

            for phase in state.get("phases", []):
                if phase["phase_id"] == current_phase:
                    # Check if ALL steps in this phase are complete (WAIT-ALL)
                    all_complete = all(
                        state["steps"].get(sid, {}).get("status") == "completed"
                        for sid in phase["step_ids"]
                    )

                    if all_complete:
                        # Release barrier
                        state["barriers"][f"{current_phase}_complete"] = True
                        phase["status"] = "completed"
                        barrier_released = True

                        # Find next phase
                        phase_ids = [p["phase_id"] for p in state["phases"]]
                        current_idx = phase_ids.index(current_phase)
                        if current_idx + 1 < len(phase_ids):
                            next_phase = phase_ids[current_idx + 1]
                            state["current_phase"] = next_phase
                            # Mark next phase as in_progress
                            for p in state["phases"]:
                                if p["phase_id"] == next_phase:
                                    p["status"] = "in_progress"
                    break

            self._write_state(state)

            return {
                "barrier_released": barrier_released,
                "next_phase": next_phase,
                "step_id": step_id,
                "current_phase": state.get("current_phase")
            }

        finally:
            self._release_lock()

    def can_start_phase(self, phase_id: str) -> bool:
        """Check if all dependencies for a phase are satisfied."""
        try:
            self._acquire_lock()
            state = self._read_state()

            for phase in state.get("phases", []):
                if phase["phase_id"] == phase_id:
                    # Check all dependencies
                    for dep in phase.get("depends_on", []):
                        if not state.get("barriers", {}).get(f"{dep}_complete", False):
                            return False
                    return True
            return False
        finally:
            self._release_lock()

    def get_phase_status(self) -> Dict:
        """Get current phase execution status."""
        try:
            self._acquire_lock()
            state = self._read_state()

            return {
                "current_phase": state.get("current_phase"),
                "barriers": state.get("barriers", {}),
                "phases": [
                    {
                        "id": p["phase_id"],
                        "status": p["status"],
                        "steps_complete": sum(
                            1 for sid in p["step_ids"]
                            if state.get("steps", {}).get(sid, {}).get("status") == "completed"
                        ),
                        "steps_total": len(p["step_ids"])
                    }
                    for p in state.get("phases", [])
                ]
            }
        finally:
            self._release_lock()


def main():
    """CLI interface for barrier manager."""
    if len(sys.argv) < 2:
        print("Usage: barrier-manager.py <command> [args]")
        print("Commands: complete <step_id> [result], can-start <phase_id>, status")
        sys.exit(1)

    manager = BarrierManager()
    command = sys.argv[1]

    if command == "complete":
        step_id = sys.argv[2] if len(sys.argv) > 2 else ""
        result = sys.argv[3] if len(sys.argv) > 3 else "success"
        print(json.dumps(manager.complete_step(step_id, result), indent=2))

    elif command == "can-start":
        phase_id = sys.argv[2] if len(sys.argv) > 2 else ""
        print(json.dumps({"can_start": manager.can_start_phase(phase_id)}))

    elif command == "status":
        print(json.dumps(manager.get_phase_status(), indent=2))

    else:
        print(f"Unknown command: {command}")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

#### 1.3 Event Types Schema

**File**: `~/.ralph/config/event-types.json`

```json
{
  "version": "2.51.0",
  "event_types": {
    "step_started": {
      "required_fields": ["step_id", "phase_id", "timestamp"],
      "triggers": ["log", "metrics"]
    },
    "step_completed": {
      "required_fields": ["step_id", "phase_id", "result", "timestamp"],
      "triggers": ["barrier_check", "log", "metrics"]
    },
    "step_failed": {
      "required_fields": ["step_id", "phase_id", "error", "timestamp"],
      "triggers": ["barrier_check", "log", "alert"]
    },
    "barrier_released": {
      "required_fields": ["phase_id", "next_phase", "timestamp"],
      "triggers": ["phase_start", "log"]
    },
    "phase_started": {
      "required_fields": ["phase_id", "execution_mode", "timestamp"],
      "triggers": ["log", "metrics"]
    },
    "phase_completed": {
      "required_fields": ["phase_id", "steps_completed", "steps_failed", "timestamp"],
      "triggers": ["log", "metrics"]
    },
    "timeout_warning": {
      "required_fields": ["phase_id", "elapsed_ms", "timeout_ms", "timestamp"],
      "triggers": ["graceful_shutdown", "log"]
    }
  }
}
```

---

### PHASE 2: Event Bus (v2.51.0) - 3-5 days

#### 2.1 Event Bus Shell Script

**File**: `~/.claude/scripts/event-bus.sh`

```bash
#!/bin/bash
# Event Bus - v2.51.0
# Manages event queue with FIFO ordering per phase

set -euo pipefail

EVENT_DIR="${HOME}/.ralph/events"
EVENT_QUEUE="${EVENT_DIR}/queue.jsonl"
LOCK_FILE="${EVENT_DIR}/queue.lock"

mkdir -p "$EVENT_DIR"

# Emit event to queue
emit_event() {
    local event_type="$1"
    local payload="$2"
    local timestamp
    timestamp=$(date -Iseconds)

    # Acquire lock
    exec 200>"$LOCK_FILE"
    flock -x 200

    # Write event
    jq -n \
        --arg type "$event_type" \
        --arg ts "$timestamp" \
        --argjson payload "$payload" \
        '{event_type: $type, timestamp: $ts, payload: $payload}' \
        >> "$EVENT_QUEUE"

    # Release lock
    flock -u 200
}

# Process next event
process_next() {
    exec 200>"$LOCK_FILE"
    flock -x 200

    if [[ ! -f "$EVENT_QUEUE" ]] || [[ ! -s "$EVENT_QUEUE" ]]; then
        echo '{"status": "empty"}'
        flock -u 200
        return
    fi

    # Read first event
    local event
    event=$(head -1 "$EVENT_QUEUE")

    # Remove from queue
    tail -n +2 "$EVENT_QUEUE" > "${EVENT_QUEUE}.tmp"
    mv "${EVENT_QUEUE}.tmp" "$EVENT_QUEUE"

    flock -u 200

    echo "$event"
}

# Get queue status
queue_status() {
    local count=0
    if [[ -f "$EVENT_QUEUE" ]]; then
        count=$(wc -l < "$EVENT_QUEUE" | tr -d ' ')
    fi
    echo "{\"pending_events\": $count}"
}

# Main
case "${1:-status}" in
    emit)
        emit_event "$2" "$3"
        ;;
    next)
        process_next
        ;;
    status)
        queue_status
        ;;
    *)
        echo "Usage: event-bus.sh {emit|next|status}"
        exit 1
        ;;
esac
```

#### 2.2 Phase Coordinator Hook

**File**: `~/.claude/hooks/phase-coordinator.sh`

```bash
#!/bin/bash
# Phase Coordinator Hook - v2.51.0
# PostToolUse hook that coordinates phase transitions

set -uo pipefail

# Parse input
INPUT=$(cat)
TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // empty')

# Only process Task completions
if [[ "$TOOL_NAME" != "Task" ]]; then
    echo '{"decision": "continue"}'
    exit 0
fi

# Extract step info from tool result
STEP_ID=$(echo "$INPUT" | jq -r '.tool_result.step_id // empty')
RESULT=$(echo "$INPUT" | jq -r '.tool_result.status // "success"')

if [[ -z "$STEP_ID" ]]; then
    echo '{"decision": "continue"}'
    exit 0
fi

# Call barrier manager
BARRIER_RESULT=$(python3 ~/.claude/scripts/barrier-manager.py complete "$STEP_ID" "$RESULT")

# Check if barrier was released
BARRIER_RELEASED=$(echo "$BARRIER_RESULT" | jq -r '.barrier_released // false')
NEXT_PHASE=$(echo "$BARRIER_RESULT" | jq -r '.next_phase // empty')

if [[ "$BARRIER_RELEASED" == "true" ]] && [[ -n "$NEXT_PHASE" ]]; then
    # Emit barrier released event
    ~/.claude/scripts/event-bus.sh emit "barrier_released" \
        "{\"phase_id\": \"$NEXT_PHASE\", \"previous_step\": \"$STEP_ID\"}"

    CONTEXT="Phase barrier released. Starting phase: $NEXT_PHASE"
    echo "{\"decision\": \"continue\", \"additionalContext\": \"$CONTEXT\"}"
else
    echo '{"decision": "continue"}'
fi
```

---

### PHASE 3: Resilience (v2.52.0) - 5-7 days

#### 3.1 Event Persistence

**File**: `~/.ralph/events/events.jsonl` (append-only log)

```jsonl
{"event_id": "uuid1", "event_type": "step_started", "phase_id": "implement", "step_id": "6a", "timestamp": "...", "committed": false}
{"event_id": "uuid1", "event_type": "step_started", "phase_id": "implement", "step_id": "6a", "timestamp": "...", "committed": true}
```

#### 3.2 Graceful Timeout Handler

**File**: `~/.claude/scripts/graceful-timeout.sh`

```bash
#!/bin/bash
# Graceful Timeout - v2.52.0
# Allows in-flight tasks to complete before shutdown

set -uo pipefail

GRACE_PERIOD_MS="${GRACE_PERIOD_MS:-30000}"  # 30 seconds default
TIMEOUT_MS="$1"
PHASE_ID="$2"

# Get in-flight steps
IN_FLIGHT=$(python3 ~/.claude/scripts/barrier-manager.py status | \
    jq -r ".phases[] | select(.id == \"$PHASE_ID\") | .steps_total - .steps_complete")

if [[ "$IN_FLIGHT" -gt 0 ]]; then
    echo "â³ Timeout reached. Waiting for $IN_FLIGHT in-flight tasks (grace: ${GRACE_PERIOD_MS}ms)..."

    # Emit timeout warning event
    ~/.claude/scripts/event-bus.sh emit "timeout_warning" \
        "{\"phase_id\": \"$PHASE_ID\", \"in_flight\": $IN_FLIGHT, \"grace_ms\": $GRACE_PERIOD_MS}"

    # Wait for grace period
    sleep $((GRACE_PERIOD_MS / 1000))

    # Check again
    STILL_IN_FLIGHT=$(python3 ~/.claude/scripts/barrier-manager.py status | \
        jq -r ".phases[] | select(.id == \"$PHASE_ID\") | .steps_total - .steps_complete")

    if [[ "$STILL_IN_FLIGHT" -gt 0 ]]; then
        echo "ðŸ”´ Grace period expired. $STILL_IN_FLIGHT tasks still running. Creating checkpoint..."
        ~/.claude/scripts/checkpoint-manager.sh save "timeout-$PHASE_ID-$(date +%s)"
    fi
fi
```

---

### PHASE 4: Observability (v2.52.0) - 3-5 days

#### 4.1 Event Tracing

**File**: `~/.claude/scripts/trace-events.sh`

```bash
#!/bin/bash
# Event Tracer - v2.52.0
# Generates distributed tracing for debugging

TRACE_FILE="${HOME}/.ralph/traces/$(date +%Y%m%d).jsonl"
mkdir -p "$(dirname "$TRACE_FILE")"

trace_event() {
    local event_type="$1"
    local span_id="$2"
    local parent_span="${3:-}"

    jq -n \
        --arg type "$event_type" \
        --arg span "$span_id" \
        --arg parent "$parent_span" \
        --arg ts "$(date -Iseconds)" \
        '{event_type: $type, span_id: $span, parent_span: $parent, timestamp: $ts}' \
        >> "$TRACE_FILE"
}
```

---

## Migration Path

```
v2.50.0 (current):
â”œâ”€â”€ Linear execution
â”œâ”€â”€ plan-state.json without phases
â””â”€â”€ No formal barriers

v2.51.0 (target):
â”œâ”€â”€ Add phase definitions to schema
â”œâ”€â”€ Implement barrier manager
â”œâ”€â”€ Event bus foundation
â””â”€â”€ Backward compatible (single-step phases = linear)

v2.52.0 (future):
â”œâ”€â”€ Full event persistence
â”œâ”€â”€ Circuit breaker
â”œâ”€â”€ Graceful timeout
â””â”€â”€ Distributed tracing
```

---

## Files to Create/Modify

| File | Action | Phase |
|------|--------|-------|
| `~/.claude/scripts/barrier-manager.py` | CREATE | 1 |
| `~/.ralph/config/event-types.json` | CREATE | 1 |
| `.claude/plan-state.json` | MODIFY (schema) | 1 |
| `~/.claude/scripts/event-bus.sh` | CREATE | 2 |
| `~/.claude/hooks/phase-coordinator.sh` | CREATE | 2 |
| `~/.claude/scripts/graceful-timeout.sh` | CREATE | 3 |
| `~/.claude/scripts/trace-events.sh` | CREATE | 4 |

---

## Estimated Timeline

| Phase | Duration | Deliverables |
|-------|----------|--------------|
| **Phase 1** | 3-5 days | Schema, BarrierManager, flock integration |
| **Phase 2** | 3-5 days | Event bus, Phase coordinator hook |
| **Phase 3** | 5-7 days | Persistence, Checkpoint, Graceful timeout |
| **Phase 4** | 3-5 days | Tracing, Dashboard |
| **Total** | **14-22 days** | Complete Event-Driven Engine |

---

## Validation Checklist

- [ ] STRICT consistency: Phase N+1 never starts until ALL sub-steps of N complete
- [ ] WAIT-ALL: All parallel tasks waited before barrier release
- [ ] SINGLE-SOURCE: File locking prevents race conditions
- [ ] GRACEFUL timeout: In-flight tasks complete before shutdown
- [ ] Events arrive out of order but execute in order
- [ ] Crash recovery via event persistence

---

*Generated by /orchestrator with adversarial validation*
*Date: 2026-01-19*
