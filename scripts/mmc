#!/usr/bin/env bash
# mmc - MiniMax Claude Code Wrapper
# Version 2.23.0
# Runs Claude Code with MiniMax M2.1 backend (~8% cost)
# v2.23: AST-grep integration for structural code search
# v2.22: Tool validation support, 9 language quality gates
# v2.21: Self-update, pre-merge validation, integrations health check
# v2.20: WorkTrunk integration, multi-agent PR review support
# Based on: https://blog.devgenius.io/claude-code-but-cheaper-and-snappy-minimax-m2-1-with-a-tiny-wrapper-7d910db93383

set -euo pipefail

# SECURITY: Ensure all created files are user-only by default (VULN-008)
umask 077

VERSION="2.23.0"
CONFIG_FILE="${HOME}/.ralph/config/minimax.json"
RALPH_DIR="${HOME}/.ralph"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

show_help() {
    cat << 'EOF'
mmc - MiniMax Claude Code Wrapper v2.21.0

Run Claude Code with MiniMax M2.1 backend (~8% of Claude's cost).
Docs: https://platform.minimax.io/docs/guides/text-ai-coding-tools

USAGE:
  mmc                     Launch Claude Code with MiniMax backend
  mmc --setup             Configure MiniMax API key
  mmc --query "prompt"    Single query to MiniMax
  mmc --loop N "task"     Loop up to N iterations (default: 30)
  mmc --lightning         Use MiniMax-lightning model (faster, 60 iter)
  mmc --second-opinion    Get second opinion on previous result
  mmc --status            Show configuration status
  mmc --stats             Show usage statistics from logs
  mmc --version           Show version
  mmc --help              Show this help

SUPPORTED MODELS (per MiniMax docs):
  MiniMax-M2.1           Primary model (~60 tps, 74% SWE-bench)
  MiniMax-M2.1-lightning Faster model (~100 tps)
  MiniMax-M2             Agentic model (advanced reasoning)

MODEL MAPPING:
  Claude Slot          -> MiniMax Model
  ------------------------------------------------
  ANTHROPIC_SMALL_FAST -> MiniMax-M2.1-lightning
  ANTHROPIC_MODEL      -> MiniMax-M2.1
  (Haiku tasks)        -> MiniMax-M2.1-lightning
  (Sonnet/Opus tasks)  -> MiniMax-M2.1

ITERATION LIMITS:
  MiniMax M2.1:         30 iterations (2x Claude)
  MiniMax-lightning:    60 iterations (4x Claude)

COST COMPARISON:
  Model             Input/M    Output/M    vs Claude    Speed
  ----------------------------------------------------------------
  Claude Sonnet     $3.00      $15.00      baseline     ~50 tps
  MiniMax M2.1      $0.30      $1.20       ~8%          ~60 tps
  MiniMax-lightning $0.15      $0.60       ~4%          ~100 tps

API NOTES (from official docs):
  - temperature: must be in (0.0, 1.0], default: 1
  - stop_sequences, top_k: ignored by MiniMax
  - Supports: text, tool_use, tool_result, thinking
  - Not supported: image, document types

EXAMPLES:
  mmc                           # Launch Claude Code with MiniMax
  mmc --setup                   # First time setup
  mmc --query "Review this code"
  mmc --loop 30 "Fix all bugs"
  mmc --lightning --loop 60 "Extended task"
EOF
}

ensure_dirs() {
    mkdir -p "${RALPH_DIR}/config"
    mkdir -p "${RALPH_DIR}/logs"
}

setup() {
    ensure_dirs

    echo -e "${BLUE}MiniMax Configuration${NC}"
    echo ""

    # ISSUE-004: Hide API key input with -s flag
    read -s -p "Enter your MiniMax API key: " API_KEY
    echo ""  # New line after hidden input

    if [ -z "$API_KEY" ]; then
        echo -e "${RED}Error: API key cannot be empty${NC}"
        exit 1
    fi

    # SECURITY: Use jq to safely construct JSON with proper escaping
    # This prevents JSON injection from malicious API key inputs
    jq -n \
        --arg apiKey "$API_KEY" \
        --arg baseUrl "https://api.minimax.io/anthropic" \
        --arg defaultModel "MiniMax-M2.1" \
        --arg lightningModel "MiniMax-M2.1-lightning" \
        '{
            apiKey: $apiKey,
            baseUrl: $baseUrl,
            defaultModel: $defaultModel,
            lightningModel: $lightningModel,
            modelMapping: {
                "claude-3-5-haiku-latest": "MiniMax-M2.1-lightning",
                "claude-sonnet-4-20250514": "MiniMax-M2.1",
                "claude-opus-4-20250514": "MiniMax-M2.1"
            }
        }' > "$CONFIG_FILE"

    chmod 600 "$CONFIG_FILE"
    echo -e "${GREEN}Configuration saved to: $CONFIG_FILE${NC}"

    # Migrate old config if exists
    if [ -f "$HOME/.mmc.json" ]; then
        echo -e "${YELLOW}Note: Old config found at ~/.mmc.json - you can remove it${NC}"
    fi
}

check_config() {
    # Check new location first, fall back to old
    if [ ! -f "$CONFIG_FILE" ]; then
        # Try old location
        if [ -f "$HOME/.mmc.json" ]; then
            CONFIG_FILE="$HOME/.mmc.json"
            echo -e "${YELLOW}Using legacy config: ~/.mmc.json${NC}"
            echo -e "${YELLOW}Run 'mmc --setup' to migrate to new location${NC}"
        else
            echo -e "${RED}Error: MiniMax not configured. Run: mmc --setup${NC}"
            exit 1
        fi
    fi
}

check_dependencies() {
    local MISSING=()

    command -v jq &>/dev/null || MISSING+=("jq")
    command -v curl &>/dev/null || MISSING+=("curl")
    command -v claude &>/dev/null || MISSING+=("claude")

    if [ ${#MISSING[@]} -gt 0 ]; then
        echo -e "${RED}Error: Missing dependencies: ${MISSING[*]}${NC}"
        echo "Install with:"
        echo "  brew install ${MISSING[*]}"
        exit 1
    fi
}

get_api_key() {
    # Support environment variable override (more secure)
    if [ -n "${MINIMAX_API_KEY:-}" ]; then
        echo "$MINIMAX_API_KEY"
    else
        jq -r '.apiKey' "$CONFIG_FILE"
    fi
}

get_base_url() {
    jq -r '.baseUrl' "$CONFIG_FILE"
}

log_usage() {
    local ACTION="$1"
    local MODEL="$2"
    local CHARS="${3:-0}"
    local TIMESTAMP
    TIMESTAMP=$(date +%s)

    # Get project name from git if available
    local PROJECT=""
    if command -v git &>/dev/null && git rev-parse --is-inside-work-tree &>/dev/null 2>&1; then
        PROJECT=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo "")
    fi

    # Build JSON entry using jq for safety
    local LOG_ENTRY
    LOG_ENTRY=$(jq -n \
        --argjson ts "$TIMESTAMP" \
        --arg action "$ACTION" \
        --arg model "$MODEL" \
        --argjson chars "$CHARS" \
        --arg project "$PROJECT" \
        '{ts: $ts, action: $action, model: $model, chars: $chars, project: $project}')

    # 1. GLOBAL LOG: ~/.ralph/logs/usage.jsonl (all sessions)
    local GLOBAL_LOG="${RALPH_DIR}/logs/usage.jsonl"
    mkdir -p "$(dirname "$GLOBAL_LOG")"
    echo "$LOG_ENTRY" >> "$GLOBAL_LOG"
    # VULN-005 FIX: Ensure log file is only readable by owner
    chmod 600 "$GLOBAL_LOG" 2>/dev/null || true

    # 2. PROJECT LOG: .ralph/usage.jsonl (per-repo tracking)
    if [ -n "$PROJECT" ]; then
        local PROJECT_ROOT
        PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
        if [ -n "$PROJECT_ROOT" ]; then
            local PROJECT_LOG="${PROJECT_ROOT}/.ralph/usage.jsonl"
            mkdir -p "$(dirname "$PROJECT_LOG")"
            echo "$LOG_ENTRY" >> "$PROJECT_LOG"
            # VULN-005 FIX: Ensure log file is only readable by owner
            chmod 600 "$PROJECT_LOG" 2>/dev/null || true
        fi
    fi
}

show_status() {
    echo -e "${BLUE}MiniMax Configuration Status${NC}"
    echo ""

    if [ -f "$CONFIG_FILE" ]; then
        echo -e "Config file: ${GREEN}$CONFIG_FILE${NC}"
        echo -e "Base URL:    $(jq -r '.baseUrl' "$CONFIG_FILE")"
        echo -e "Model:       $(jq -r '.defaultModel' "$CONFIG_FILE")"
        echo -e "Lightning:   $(jq -r '.lightningModel' "$CONFIG_FILE")"

        # Test connection with a minimal messages request
        echo ""
        echo -n "API Status:  "
        local API_KEY=$(get_api_key)
        local BASE_URL=$(get_base_url)

        # Use messages endpoint with minimal request (MiniMax doesn't have /v1/models)
        local TEST_RESPONSE
        TEST_RESPONSE=$(curl -s --max-time 10 "${BASE_URL}/v1/messages" \
            -H "Authorization: Bearer $API_KEY" \
            -H "Content-Type: application/json" \
            -H "anthropic-version: 2023-06-01" \
            -d '{"model":"MiniMax-M2.1","max_tokens":1,"messages":[{"role":"user","content":"1"}]}' 2>&1)

        if echo "$TEST_RESPONSE" | grep -q '"content"'; then
            echo -e "${GREEN}Connected${NC}"
        elif echo "$TEST_RESPONSE" | grep -q '"error"'; then
            local ERROR_MSG=$(echo "$TEST_RESPONSE" | jq -r '.error.message // "Unknown error"' 2>/dev/null)
            echo -e "${RED}Error: $ERROR_MSG${NC}"
        else
            echo -e "${YELLOW}Unable to verify (check API key)${NC}"
        fi
    else
        echo -e "Config file: ${RED}Not found${NC}"
        echo ""
        echo "Run 'mmc --setup' to configure"
    fi
}

query() {
    local PROMPT="$1"
    local MODEL="${2:-MiniMax-M2.1}"
    local TEMPERATURE="${3:-1}"  # Per docs: (0.0, 1.0], recommended: 1

    log_usage "query" "$MODEL" "${#PROMPT}"

    check_config
    check_dependencies

    local API_KEY=$(get_api_key)
    local BASE_URL=$(get_base_url)

    # SECURITY: Properly escape prompt to prevent JSON injection
    local ESCAPED_PROMPT
    ESCAPED_PROMPT=$(printf '%s' "$PROMPT" | jq -Rs '.')

    # Per MiniMax docs: https://platform.minimax.io/docs/api-reference/text-anthropic-api
    # - temperature must be in (0.0, 1.0]
    # - stop_sequences and top_k are ignored
    local RESPONSE
    RESPONSE=$(curl -s --max-time 300 "${BASE_URL}/v1/messages" \
        -H "Authorization: Bearer $API_KEY" \
        -H "Content-Type: application/json" \
        -H "anthropic-version: 2023-06-01" \
        -d "{
            \"model\": \"$MODEL\",
            \"max_tokens\": 4096,
            \"temperature\": $TEMPERATURE,
            \"messages\": [{\"role\": \"user\", \"content\": $ESCAPED_PROMPT}]
        }" 2>&1)

    # Handle response - check for thinking content too
    local TEXT_CONTENT
    TEXT_CONTENT=$(echo "$RESPONSE" | jq -r '
        .content[] |
        select(.type == "text") |
        .text
    ' 2>/dev/null | head -1)

    if [ -n "$TEXT_CONTENT" ] && [ "$TEXT_CONTENT" != "null" ]; then
        echo "$TEXT_CONTENT"
    else
        # Fallback to error message or raw response
        echo "$RESPONSE" | jq -r '.error.message // "Error: Unable to parse response"' 2>/dev/null || echo "$RESPONSE"
    fi
}

launch_claude_code() {
    check_config
    check_dependencies

    local API_KEY=$(get_api_key)
    local BASE_URL=$(get_base_url)
    local USE_LIGHTNING="${1:-false}"
    shift || true

    local MODEL="MiniMax-M2.1"
    local SMALL_MODEL="MiniMax-M2.1-lightning"

    if [ "$USE_LIGHTNING" = "true" ]; then
        MODEL="MiniMax-M2.1-lightning"
    fi

    log_usage "chat" "$MODEL" "0"

    echo -e "${BLUE}Launching Claude Code with MiniMax backend${NC}"
    echo -e "   Model: ${GREEN}$MODEL${NC}"
    echo -e "   Small/Fast: ${GREEN}$SMALL_MODEL${NC}"
    echo ""

    # Environment variables per MiniMax documentation:
    # https://platform.minimax.io/docs/guides/text-ai-coding-tools
    ANTHROPIC_API_KEY="$API_KEY" \
    ANTHROPIC_BASE_URL="$BASE_URL" \
    ANTHROPIC_MODEL="$MODEL" \
    ANTHROPIC_SMALL_FAST_MODEL="$SMALL_MODEL" \
    ANTHROPIC_DEFAULT_SONNET_MODEL="$MODEL" \
    ANTHROPIC_DEFAULT_OPUS_MODEL="$MODEL" \
    ANTHROPIC_DEFAULT_HAIKU_MODEL="$SMALL_MODEL" \
    API_TIMEOUT_MS="3000000" \
    CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC="1" \
    claude "$@"
}

loop() {
    local MAX_ITER="${1:-30}"
    shift
    local TASK="$*"

    log_usage "loop" "MiniMax-M2.1" "${#TASK}"

    check_config
    check_dependencies

    echo -e "${BLUE}Starting loop: $MAX_ITER iterations max${NC}"
    echo -e "   Task: $TASK"
    echo ""

    local ITER=0
    while [ $ITER -lt $MAX_ITER ]; do
        ((ITER++))
        echo -e "${YELLOW}[Iteration $ITER/$MAX_ITER]${NC}"

        RESULT=$(query "$TASK. If complete, respond with VERIFIED_DONE.")
        echo "$RESULT"
        echo ""

        if echo "$RESULT" | grep -q "VERIFIED_DONE"; then
            echo -e "${GREEN}Task completed at iteration $ITER${NC}"
            return 0
        fi
    done

    echo -e "${YELLOW}Max iterations reached without VERIFIED_DONE${NC}"
    return 1
}

cmd_stats() {
    local SCOPE="${1:-all}"
    local GLOBAL_LOG="${RALPH_DIR}/logs/usage.jsonl"
    local PROJECT_LOG=""

    # Check for project-level log
    if command -v git &>/dev/null && git rev-parse --is-inside-work-tree &>/dev/null 2>&1; then
        local PROJECT_ROOT
        PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
        if [ -n "$PROJECT_ROOT" ] && [ -f "${PROJECT_ROOT}/.ralph/usage.jsonl" ]; then
            PROJECT_LOG="${PROJECT_ROOT}/.ralph/usage.jsonl"
        fi
    fi

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "              MINIMAX USAGE STATISTICS (v2.19)"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    # GLOBAL STATS
    if [[ "$SCOPE" == "all" ]] || [[ "$SCOPE" == "global" ]]; then
        echo "ğŸ“Š GLOBAL USAGE (all projects)"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        if [[ -f "$GLOBAL_LOG" ]]; then
            echo "  Log: $GLOBAL_LOG"
            echo "  Total queries: $(wc -l < "$GLOBAL_LOG" | tr -d ' ')"
            echo ""
            echo "  By model:"
            jq -r '.model' "$GLOBAL_LOG" 2>/dev/null | sort | uniq -c | sed 's/^/    /'
            echo ""
            echo "  By project:"
            jq -r '.project // "unknown"' "$GLOBAL_LOG" 2>/dev/null | sort | uniq -c | sed 's/^/    /'
            echo ""
            echo "  Total chars: $(jq -s '[.[].chars] | add' "$GLOBAL_LOG" 2>/dev/null || echo "N/A")"
        else
            echo "  No global logs found"
        fi
        echo ""
    fi

    # PROJECT STATS
    if [[ "$SCOPE" == "all" ]] || [[ "$SCOPE" == "project" ]]; then
        echo "ğŸ“ PROJECT USAGE (this repo only)"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        if [[ -n "$PROJECT_LOG" ]] && [[ -f "$PROJECT_LOG" ]]; then
            echo "  Log: $PROJECT_LOG"
            echo "  Total queries: $(wc -l < "$PROJECT_LOG" | tr -d ' ')"
            echo ""
            echo "  By model:"
            jq -r '.model' "$PROJECT_LOG" 2>/dev/null | sort | uniq -c | sed 's/^/    /'
            echo ""
            echo "  By action:"
            jq -r '.action' "$PROJECT_LOG" 2>/dev/null | sort | uniq -c | sed 's/^/    /'
            echo ""
            echo "  Total chars: $(jq -s '[.[].chars] | add' "$PROJECT_LOG" 2>/dev/null || echo "N/A")"
        else
            echo "  No project-level logs found (not in a git repo or no usage yet)"
        fi
        echo ""
    fi

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  Usage: mmc --stats [all|global|project]"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
}

main() {
    local CMD="${1:-launch}"

    case "$CMD" in
        --setup|setup)
            setup
            ;;
        --query|-q)
            shift
            query "$*"
            ;;
        --loop|-l)
            shift
            loop "$@"
            ;;
        --lightning)
            shift
            if [ "${1:-}" = "--loop" ]; then
                shift
                local MAX="${1:-60}"
                shift
                echo -e "${BLUE}Using MiniMax-lightning (60 iter max)${NC}"
                loop "$MAX" "$@"
            else
                launch_claude_code true "$@"
            fi
            ;;
        --second-opinion)
            shift
            query "As a second opinion, review this: $*"
            ;;
        --status)
            show_status
            ;;
        --stats)
            shift
            cmd_stats "${1:-all}"
            ;;
        --version|-v)
            echo "mmc v$VERSION"
            ;;
        --help|-h)
            show_help
            ;;
        launch|"")
            shift 2>/dev/null || true
            launch_claude_code false "$@"
            ;;
        *)
            # Pass through to claude code with MiniMax
            launch_claude_code false "$@"
            ;;
    esac
}

main "$@"
