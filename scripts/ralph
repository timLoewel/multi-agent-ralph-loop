#!/usr/bin/env bash
# ralph - Multi-Agent Orchestrator CLI
# Version 2.22.0
# v2.22: Tool validation (startup + on-demand), 9 language quality gates
# v2.21: Self-update, pre-merge validation, integrations health check
# v2.20: Git worktree + PR workflow with multi-agent review
# v2.19: Security fixes (VULN-001, VULN-004, VULN-008), improved validation
set -euo pipefail

# SECURITY: Ensure all created files are user-only by default (VULN-008)
umask 077

VERSION="2.23.0"
RALPH_REPO_PATH=""  # Auto-detected if in ralph repo
RALPH_DIR="${HOME}/.ralph"

# SECURITY: Use mktemp for unpredictable temp directory
RALPH_TMPDIR=""
init_tmpdir() {
    if [ -z "$RALPH_TMPDIR" ]; then
        local SYSTEM_TMPDIR="${TMPDIR:-/tmp}"
        RALPH_TMPDIR=$(mktemp -d "${SYSTEM_TMPDIR}/ralph.XXXXXXXXXX")
        chmod 700 "$RALPH_TMPDIR"
    fi
}

# SECURITY: Validate file path input (prevent command injection)
# v2.19: VULN-004 FIX - Use realpath -e to resolve symlinks, improved validation
validate_path() {
    local path="$1"
    local check_exists="${2:-check}"

    # Block control characters (newlines, carriage returns, null bytes, etc.)
    if [[ "$path" =~ [[:cntrl:]] ]]; then
        log_error "Control characters not allowed in path"
        exit 1
    fi

    # Block shell metacharacters including glob patterns (*, ?, [])
    if [[ "$path" =~ [\;\|\&\$\`\(\)\{\}\<\>\*\?\[\]\!\~\#] ]]; then
        log_error "Invalid characters in path: $path"
        exit 1
    fi

    # Block path traversal attempts
    if [[ "$path" =~ \.\. ]]; then
        log_error "Path traversal not allowed: $path"
        exit 1
    fi

    # VULN-004 FIX: Use realpath -e to resolve symlinks and validate existence
    if [ "$check_exists" = "check" ]; then
        local canonical_path
        # -e flag: resolve all symlinks, path must exist
        canonical_path=$(realpath -e "$path" 2>/dev/null)

        if [ -z "$canonical_path" ]; then
            log_error "Path does not exist or contains invalid symlinks: $path"
            exit 1
        fi

        # Return the fully resolved canonical path
        printf '%s' "$canonical_path"
    else
        # For paths that don't need to exist yet, use -s (logical) but warn
        realpath -s "$path" 2>/dev/null || printf '%s' "$path"
    fi
}

# SECURITY: Validate text input (for non-path user inputs like TASK, QUERY)
# v2.17: NEW - Validates free-form text inputs
validate_text_input() {
    local input="$1"
    local max_len="${2:-10000}"

    # Block control characters except space/tab/newline
    if [[ "$input" =~ [[:cntrl:]] ]] && ! [[ "$input" =~ ^[[:print:][:space:]]*$ ]]; then
        log_error "Invalid control characters in input"
        exit 1
    fi

    # Check length limit
    if [ ${#input} -gt "$max_len" ]; then
        log_error "Input too long (max: $max_len characters)"
        exit 1
    fi

    printf '%s' "$input"
}

# SECURITY: Escape string for safe shell usage (VULN-001 FIX)
# v2.19: Use printf %q for proper escaping (prevents command substitution)
escape_for_shell() {
    # printf %q properly escapes all special characters including $() and ``
    printf '%q' "$1"
}
IMPROVEMENTS_DIR="${RALPH_DIR}/improvements"
CONFIG_DIR="${RALPH_DIR}/config"
HOOKS_DIR="${HOME}/.claude/hooks"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Iteration Limits
CLAUDE_MAX_ITER=15
MINIMAX_MAX_ITER=30
LIGHTNING_MAX_ITER=60

# Model Configuration by Task Type (v2.21)
# Based on efficiency analysis: quality > speed > rework > context
EXPLORATION_MODEL="minimax"     # Research, exploration, docs - 1M context, 8% cost
IMPLEMENTATION_MODEL="sonnet"   # Features, refactors, tests - balanced quality/speed
REVIEW_MODEL="opus"             # Pre-merge critical review - surgical precision
VALIDATION_MODEL="minimax"      # Second opinion, parallel review - Opus quality at 8% cost

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TOOL VALIDATION (v2.22)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Herramientas cr√≠ticas - requeridas siempre
CRITICAL_TOOLS=(
    "claude:Claude Code CLI:brew install anthropic/tap/claude-code"
    "jq:JSON processor:brew install jq"
    "git:Version control:brew install git"
)

# Herramientas de features - requeridas para features espec√≠ficos
FEATURE_TOOLS=(
    "wt:WorkTrunk (git worktree):brew install max-sixty/worktrunk/wt"
    "gh:GitHub CLI (PR workflow):brew install gh && gh auth login"
    "mmc:MiniMax CLI (second opinion):ralph self-update && mmc --setup"
    "codex:Codex CLI (adversarial):npm i -g @openai/codex"
    "gemini:Gemini CLI (research):pip install google-gemini-cli"
    "sg:ast-grep (structural code search):brew install ast-grep"
)

# Herramientas para Quality Gates (9 lenguajes)
QUALITY_GATE_TOOLS=(
    # TypeScript/JavaScript
    "npx:Node.js package executor (TypeScript, ESLint):brew install node"
    "typescript-language-server:TypeScript LSP:npm i -g typescript-language-server typescript"
    # Python
    "pyright:Python type checker:npm i -g pyright"
    "ruff:Python linter:pip install ruff"
    # Go
    "go:Go compiler:brew install go"
    "staticcheck:Go static analyzer:go install honnef.co/go/tools/cmd/staticcheck@latest"
    # Rust
    "cargo:Rust package manager:brew install rust"
    # Solidity
    "forge:Foundry (Solidity):curl -L https://foundry.paradigm.xyz | bash && foundryup"
    "solhint:Solidity linter:npm i -g solhint"
    # Swift
    "swiftlint:Swift linter:brew install swiftlint"
    # JSON/YAML
    "yamllint:YAML linter:pip install yamllint"
)

# v2.22: Startup validation (fast, non-blocking)
startup_validation() {
    local MISSING_CRITICAL=()
    local MISSING_FEATURE=()
    local MISSING_QUALITY=()

    # Check critical tools (always warn)
    for tool_entry in "${CRITICAL_TOOLS[@]}"; do
        local tool_name="${tool_entry%%:*}"
        command -v "$tool_name" &>/dev/null || MISSING_CRITICAL+=("$tool_name")
    done

    # Check feature tools (informational)
    for tool_entry in "${FEATURE_TOOLS[@]}"; do
        local tool_name="${tool_entry%%:*}"
        command -v "$tool_name" &>/dev/null || MISSING_FEATURE+=("$tool_name")
    done

    # Check quality gate tools (informational - 9 languages)
    for tool_entry in "${QUALITY_GATE_TOOLS[@]}"; do
        local tool_name="${tool_entry%%:*}"
        command -v "$tool_name" &>/dev/null || MISSING_QUALITY+=("$tool_name")
    done

    # Critical tools - always warn (blocking for most commands)
    if [ ${#MISSING_CRITICAL[@]} -gt 0 ]; then
        log_error "Missing critical tools: ${MISSING_CRITICAL[*]}"
        log_info "Run 'ralph integrations' for installation instructions"
        echo ""
    fi

    # Feature + Quality tools - show once per session
    if [ -z "${RALPH_STARTUP_SHOWN:-}" ]; then
        export RALPH_STARTUP_SHOWN=1

        if [ ${#MISSING_FEATURE[@]} -gt 0 ]; then
            log_info "Feature tools not installed: ${MISSING_FEATURE[*]}"
        fi

        if [ ${#MISSING_QUALITY[@]} -gt 0 ]; then
            log_info "Quality gate tools missing (${#MISSING_QUALITY[@]}/11): some language checks may be skipped"
        fi

        if [ ${#MISSING_FEATURE[@]} -gt 0 ] || [ ${#MISSING_QUALITY[@]} -gt 0 ]; then
            log_info "Run 'ralph integrations' for details"
            echo ""
        fi
    fi
}

# v2.22: On-demand tool validation (blocking with install instructions)
require_tool() {
    local TOOL_NAME="$1"
    local FEATURE_NAME="${2:-this feature}"

    command -v "$TOOL_NAME" &>/dev/null && return 0

    local INSTALL_INSTRUCTIONS="" TOOL_DESC=""
    for tool_entry in "${CRITICAL_TOOLS[@]}" "${FEATURE_TOOLS[@]}" "${QUALITY_GATE_TOOLS[@]}"; do
        local entry_name="${tool_entry%%:*}"
        if [ "$entry_name" = "$TOOL_NAME" ]; then
            local remainder="${tool_entry#*:}"
            TOOL_DESC="${remainder%%:*}"
            INSTALL_INSTRUCTIONS="${remainder#*:}"
            break
        fi
    done

    echo ""
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë  ERROR: MISSING REQUIRED TOOL                                 ‚ïë"
    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
    echo "‚ïë                                                               ‚ïë"
    printf "‚ïë  Tool:        %s\n" "$TOOL_NAME"
    [ -n "$TOOL_DESC" ] && printf "‚ïë  Description: %s\n" "$TOOL_DESC"
    printf "‚ïë  Required for: %s\n" "$FEATURE_NAME"
    echo "‚ïë                                                               ‚ïë"
    echo "‚ïë  Installation:                                                ‚ïë"
    printf "‚ïë    %s\n" "$INSTALL_INSTRUCTIONS"
    echo "‚ïë                                                               ‚ïë"
    echo "‚ïë  After installation, run: ralph integrations                  ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"

    exit 1
}

# v2.22: Require multiple tools at once
require_tools() {
    local FEATURE_NAME="$1"
    shift
    local MISSING=()

    for tool in "$@"; do
        command -v "$tool" &>/dev/null || MISSING+=("$tool")
    done

    [ ${#MISSING[@]} -eq 0 ] && return 0

    echo ""
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    printf "‚ïë  ERROR: MISSING REQUIRED TOOLS FOR: %s\n" "$FEATURE_NAME"
    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"

    for tool in "${MISSING[@]}"; do
        for tool_entry in "${CRITICAL_TOOLS[@]}" "${FEATURE_TOOLS[@]}" "${QUALITY_GATE_TOOLS[@]}"; do
            local entry_name="${tool_entry%%:*}"
            if [ "$entry_name" = "$tool" ]; then
                local remainder="${tool_entry#*:}"
                printf "‚ïë  - %s: %s\n" "$tool" "${remainder%%:*}"
                printf "‚ïë    Install: %s\n" "${remainder#*:}"
                break
            fi
        done
    done

    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    exit 1
}

# Model CLI commands
get_model_cli() {
    local MODEL_TYPE="$1"
    case "$MODEL_TYPE" in
        exploration|validation)
            echo "mmc --query"
            ;;
        implementation)
            echo "claude --print -m sonnet"
            ;;
        review)
            echo "claude --print -m opus"
            ;;
        *)
            echo "claude --print -m sonnet"
            ;;
    esac
}

# Cleanup
cleanup() {
    [ -n "$RALPH_TMPDIR" ] && rm -rf "$RALPH_TMPDIR" 2>/dev/null || true
}
trap cleanup EXIT

ensure_tmp() {
    init_tmpdir
}
ensure_dirs() { mkdir -p "$IMPROVEMENTS_DIR/backups" "$CONFIG_DIR"; }

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# ===============================================================================
# HELP
# ===============================================================================
show_help() {
    cat << 'EOF'
ralph - Multi-Agent Orchestrator CLI v2.23.0

ORCHESTRATION:
  ralph orch "task"          Full orchestration (clarify->classify->execute->validate->retrospective)
  ralph loop "task"          Loop until VERIFIED_DONE (max 15 iter Claude, 30 MiniMax)
  ralph clarify "task"       Generate clarification questions

SEARCH (v2.23):
  ralph ast "pattern" [path] Structural code search via ast-grep (~75% less tokens)
                             Examples: ralph ast 'console.log($MSG)' src/
                                       ralph ast 'async function $NAME' .

GIT WORKTREE + PR WORKFLOW (v2.20):
  ralph worktree "task"      Create isolated worktree for feature
  ralph worktree-pr          Create PR with Claude + Codex review
  ralph worktree-merge <pr>  Merge approved PR and cleanup
  ralph worktree-fix <pr>    Apply fixes from review comments
  ralph worktree-close <pr>  Close PR and cleanup without merge
  ralph worktree-status      Show all worktrees and PR status
  ralph worktree-cleanup     Clean up merged worktrees

REVIEW (6 SUBAGENTS):
  ralph review <path>        Multi-model review
  ralph parallel <path>      All 6 subagents in parallel
  ralph full-review <path>   Alias for parallel

SPECIALIZED:
  ralph security <path>      Security audit (Codex + MiniMax)
  ralph bugs <path>          Bug hunting (Codex)
  ralph unit-tests <path>    Unit tests (Codex, 90% coverage)
  ralph integration <path>   Integration tests (Gemini)
  ralph refactor <path>      Refactoring (Codex)
  ralph research "query"     Web research (Gemini)
  ralph minimax "query"      Second opinion (MiniMax ~8% cost)

VALIDATION:
  ralph gates                Quality gates (9 languages) - BLOCKING
  ralph gates --check        Quality gates (non-blocking check only)
  ralph adversarial <path>   2/3 consensus (Claude + Codex + Gemini)

SELF-IMPROVEMENT:
  ralph retrospective        Analyze last task, propose improvements
  ralph retro                Alias for retrospective
  ralph improvements         List pending improvements
  ralph improvements apply   Apply pending improvements
  ralph improvements reject  Reject improvements

UTILITY:
  ralph status               Show active processes
  ralph version              Show version
  ralph help                 Show this help
  ralph --uninstall          Uninstall ralph and all components

MAINTENANCE (v2.21):
  ralph self-update          Sync scripts from repo to ~/.local/bin/
  ralph pre-merge            Validate before creating PR (shellcheck + versions + tests)
  ralph integrations         Show status of all integrations (Greptile optional)

ITERATION LIMITS:
  Claude (Sonnet/Opus): 15 iterations
  MiniMax M2.1:         30 iterations (2x)
  MiniMax-lightning:    60 iterations (4x)

ALIASES (add to ~/.zshrc or ~/.bashrc):
  alias rh='ralph'
  alias rho='ralph orch'
  alias rhr='ralph review'
  alias rhp='ralph parallel'
  alias rhs='ralph security'
  alias rhb='ralph bugs'
  alias rhu='ralph unit-tests'
  alias rhf='ralph refactor'
  alias rhres='ralph research'
  alias rhm='ralph minimax'
  alias rhg='ralph gates'
  alias rha='ralph adversarial'
  alias rhl='ralph loop'
  alias rhc='ralph clarify'
  alias rhret='ralph retrospective'
  alias rhi='ralph improvements'
  alias rhast='ralph ast'
  alias rhw='ralph worktree'
  alias rhwp='ralph worktree-pr'
  alias rhws='ralph worktree-status'
  alias rhsu='ralph self-update'
  alias rhpm='ralph pre-merge'
  alias rhint='ralph integrations'

EXAMPLES:
  ralph orch "Implement OAuth2 with Google"
  ralph security src/auth/
  ralph parallel src/ --async
  ralph adversarial src/payments/
  ralph loop "Fix all TypeScript errors"
  ralph retrospective

  # Worktree workflow (v2.20)
  ralph worktree "implement user authentication"
  cd .worktrees/ai-ralph-*/  # Work in isolated worktree
  ralph worktree-pr          # Create PR with multi-agent review
  ralph worktree-merge 123   # Merge approved PR
EOF
}

# ===============================================================================
# CODEX SUBAGENTS
# ===============================================================================
run_codex_security() {
    local FILES
    FILES=$(validate_path "$1")
    local OUTPUT="$RALPH_TMPDIR/codex_security.json"
    local SAFE_FILES
    SAFE_FILES=$(escape_for_shell "$FILES")

    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Use security-review skill. Analyze for vulnerabilities in: ${SAFE_FILES}

         Output JSON: {vulnerabilities: [{severity, type, file, line, description, fix}], summary: {critical, high, medium, low, approved}}" \
        > "$OUTPUT" 2>&1 &
    echo $!
}

run_codex_bugs() {
    local FILES
    FILES=$(validate_path "$1")
    local OUTPUT="$RALPH_TMPDIR/codex_bugs.json"
    local SAFE_FILES
    SAFE_FILES=$(escape_for_shell "$FILES")

    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Use bug-hunter skill. Find bugs in: ${SAFE_FILES}

         Output JSON: {bugs: [{severity, type, file, line, description, fix}], summary: {total, high, medium, low, approved}}" \
        > "$OUTPUT" 2>&1 &
    echo $!
}

run_codex_unit_tests() {
    local FILES
    FILES=$(validate_path "$1")
    local OUTPUT="$RALPH_TMPDIR/codex_tests.json"
    local SAFE_FILES
    SAFE_FILES=$(escape_for_shell "$FILES")

    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Use test-generation skill. Generate unit tests for: ${SAFE_FILES}
         Target: 90% coverage. Include edge cases and error paths.

         Output JSON: {tests: [{file, content, coverage, type}], summary: {total_tests, estimated_coverage}}" \
        > "$OUTPUT" 2>&1 &
    echo $!
}

# ===============================================================================
# GEMINI SUBAGENTS
# ===============================================================================
run_gemini_integration() {
    local FILES
    FILES=$(validate_path "$1")
    local OUTPUT="$RALPH_TMPDIR/gemini_integration.txt"
    local SAFE_FILES
    SAFE_FILES=$(escape_for_shell "$FILES")

    gemini "Generate comprehensive integration tests for: ${SAFE_FILES}
            Include: API tests, database tests, external service mocks.
            Output ready-to-run test files." \
        --yolo -o text > "$OUTPUT" 2>&1 &
    echo $!
}

run_gemini_research() {
    local QUERY
    QUERY=$(validate_text_input "$1")
    local OUTPUT="$RALPH_TMPDIR/gemini_research.txt"
    local SAFE_QUERY
    SAFE_QUERY=$(escape_for_shell "$QUERY")

    gemini "${SAFE_QUERY}" --yolo -o text > "$OUTPUT" 2>&1 &
    echo $!
}

# ===============================================================================
# MINIMAX SUBAGENTS
# ===============================================================================
run_minimax() {
    local QUERY
    QUERY=$(validate_text_input "$1")
    local OUTPUT="${2:-$RALPH_TMPDIR/minimax_result.json}"

    # Check for MiniMax config: primary path, then legacy fallback
    local MINIMAX_CONFIG=""
    if [ -f "${CONFIG_DIR}/minimax.json" ]; then
        MINIMAX_CONFIG="${CONFIG_DIR}/minimax.json"
    elif [ -f "${RALPH_DIR}/config/minimax.json" ]; then
        MINIMAX_CONFIG="${RALPH_DIR}/config/minimax.json"
    elif [ -f "${HOME}/.mmc.json" ]; then
        MINIMAX_CONFIG="${HOME}/.mmc.json"  # Legacy fallback
    fi

    if command -v mmc &> /dev/null && [ -n "$MINIMAX_CONFIG" ]; then
        local SAFE_QUERY
        SAFE_QUERY=$(escape_for_shell "$QUERY")
        mmc --query "${SAFE_QUERY}" > "$OUTPUT" 2>&1 &
        echo $!
    else
        echo "0"  # MiniMax not configured
    fi
}

# ===============================================================================
# ADVERSARIAL VALIDATION
# ===============================================================================
cmd_adversarial() {
    # v2.22: Require codex and gemini tools for adversarial validation
    require_tools "adversarial validation" "codex" "gemini"

    local TARGET
    TARGET=$(validate_path "$1")
    local CONSENSUS_REQUIRED=2
    local SAFE_TARGET
    SAFE_TARGET=$(escape_for_shell "$TARGET")

    ensure_tmp
    log_info "Starting adversarial validation for: $TARGET"
    log_info "   Consensus required: $CONSENSUS_REQUIRED/3"
    echo ""

    # 1. Claude Review
    log_info "  [1/3] Claude reviewing..."
    claude --print -p "Review this code for security and bugs: ${SAFE_TARGET}.
                       Output JSON: {approved: true|false, issues: [], severity: 'HIGH|MEDIUM|LOW'}" \
        > "$RALPH_TMPDIR/claude.json" 2>&1 &
    CLAUDE_PID=$!

    # 2. Codex Review (parallel)
    log_info "  [2/3] Codex reviewing..."
    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Use security-review skill. Review: ${SAFE_TARGET}
         Output JSON: {approved: true|false, issues: [], severity}" \
        > "$RALPH_TMPDIR/codex.json" 2>&1 &
    CODEX_PID=$!

    # 3. Gemini Review (parallel)
    log_info "  [3/3] Gemini reviewing..."
    gemini "Security and code review for: ${SAFE_TARGET}
            Be critical. Output JSON: {approved: true|false, issues: []}" \
        --yolo -o json > "$RALPH_TMPDIR/gemini.json" 2>&1 &
    GEMINI_PID=$!

    echo ""
    log_info "Waiting for all 3 models..."
    wait $CLAUDE_PID $CODEX_PID $GEMINI_PID

    # Calculate consensus
    CLAUDE_APPROVED=$(grep -o '"approved":\s*true' "$RALPH_TMPDIR/claude.json" 2>/dev/null && echo "true" || echo "false")
    CODEX_APPROVED=$(grep -o '"approved":\s*true' "$RALPH_TMPDIR/codex.json" 2>/dev/null && echo "true" || echo "false")
    GEMINI_APPROVED=$(grep -o '"approved":\s*true' "$RALPH_TMPDIR/gemini.json" 2>/dev/null && echo "true" || echo "false")

    APPROVALS=0
    [[ "$CLAUDE_APPROVED" == "true" ]] && ((APPROVALS++)) || true
    [[ "$CODEX_APPROVED" == "true" ]] && ((APPROVALS++)) || true
    [[ "$GEMINI_APPROVED" == "true" ]] && ((APPROVALS++)) || true

    echo ""
    echo "==============================================================="
    echo "  ADVERSARIAL VALIDATION RESULTS"
    echo "==============================================================="
    echo ""
    echo "  Claude:  $([ "$CLAUDE_APPROVED" == "true" ] && echo "Approved" || echo "Rejected")"
    echo "  Codex:   $([ "$CODEX_APPROVED" == "true" ] && echo "Approved" || echo "Rejected")"
    echo "  Gemini:  $([ "$GEMINI_APPROVED" == "true" ] && echo "Approved" || echo "Rejected")"
    echo ""
    echo "  Consensus: $APPROVALS/3 (required: $CONSENSUS_REQUIRED)"
    echo ""

    if [[ $APPROVALS -ge $CONSENSUS_REQUIRED ]]; then
        log_success "ADVERSARIAL VALIDATION PASSED"
        echo "==============================================================="
        return 0
    else
        log_error "ADVERSARIAL VALIDATION FAILED"
        echo ""
        echo "  Issues found:"
        jq -s '.[].issues // [] | .[]' "$RALPH_TMPDIR"/*.json 2>/dev/null | head -20
        echo "==============================================================="
        return 2
    fi
}

# ===============================================================================
# PARALLEL REVIEW (6 SUBAGENTS)
# ===============================================================================
cmd_parallel() {
    local TARGET
    TARGET=$(validate_path "$1")
    local ASYNC="${2:-false}"

    ensure_tmp
    log_info "Launching 6 parallel subagents for: $TARGET"
    echo ""

    declare -a PIDS

    # 1. Codex Security
    PID=$(run_codex_security "$TARGET")
    PIDS+=("$PID")
    log_info "  [1/6] Codex Security: PID $PID"

    # 2. Codex Bugs
    PID=$(run_codex_bugs "$TARGET")
    PIDS+=("$PID")
    log_info "  [2/6] Codex Bugs: PID $PID"

    # 3. Codex Unit Tests
    PID=$(run_codex_unit_tests "$TARGET")
    PIDS+=("$PID")
    log_info "  [3/6] Codex Unit Tests: PID $PID"

    # 4. Gemini Integration
    PID=$(run_gemini_integration "$TARGET")
    PIDS+=("$PID")
    log_info "  [4/6] Gemini Integration: PID $PID"

    # 5. Gemini Research
    PID=$(run_gemini_research "code quality best practices for $TARGET")
    PIDS+=("$PID")
    log_info "  [5/6] Gemini Research: PID $PID"

    # 6. MiniMax Second Opinion
    PID=$(run_minimax "Provide critical code review for: $TARGET")
    if [ "$PID" != "0" ]; then
        PIDS+=("$PID")
        log_info "  [6/6] MiniMax Review: PID $PID"
    else
        log_warn "  [6/6] MiniMax: skipped (not configured)"
    fi

    echo ""

    if [ "$ASYNC" = "--async" ] || [ "$ASYNC" = "true" ]; then
        log_warn "Fire & forget mode. PIDs: ${PIDS[*]}"
        log_info "   Check results in: $RALPH_TMPDIR/"
        return 0
    fi

    log_info "Waiting for ${#PIDS[@]} subagents..."
    for pid in "${PIDS[@]}"; do
        wait "$pid" 2>/dev/null || true
    done

    log_success "All subagents completed"
    echo ""

    # Summary
    echo "==============================================================="
    echo "  PARALLEL REVIEW SUMMARY"
    echo "==============================================================="
    for f in "$RALPH_TMPDIR"/*; do
        if [ -f "$f" ]; then
            local name=$(basename "$f")
            local lines=$(wc -l < "$f" 2>/dev/null || echo 0)
            echo "  - $name: $lines lines"
        fi
    done
    echo "==============================================================="
}

# ===============================================================================
# QUALITY GATES (9 LANGUAGES)
# ===============================================================================
cmd_gates() {
    local CHECK_ONLY="${1:-}"
    local HOOK_SCRIPT="${HOOKS_DIR}/quality-gates.sh"

    # Check if hook exists
    if [ ! -f "$HOOK_SCRIPT" ]; then
        log_error "Quality gates hook not found at: $HOOK_SCRIPT"
        log_info "Run the installer to set up hooks: ./install.sh"
        return 1
    fi

    # Ensure executable
    if [ ! -x "$HOOK_SCRIPT" ]; then
        chmod +x "$HOOK_SCRIPT"
    fi

    # Run in blocking or check mode
    if [ "$CHECK_ONLY" = "--check" ]; then
        log_info "Running quality gates (non-blocking check)..."
        RALPH_GATES_BLOCKING=0 "$HOOK_SCRIPT"
    else
        log_info "Running quality gates (blocking mode)..."
        RALPH_GATES_BLOCKING=1 "$HOOK_SCRIPT"
    fi
}

# ===============================================================================
# SPECIALIZED COMMANDS
# ===============================================================================
cmd_security() {
    local TARGET
    TARGET=$(validate_path "$1")
    ensure_tmp

    log_info "Running security audit on: $TARGET"

    # Codex (primary)
    log_info "  Starting Codex security audit..."
    PID1=$(run_codex_security "$TARGET")

    # MiniMax (second opinion)
    PID2=$(run_minimax "Security audit for: $TARGET. Check: injection, auth, secrets, crypto." "$RALPH_TMPDIR/minimax_security.json")

    if [ "$PID2" != "0" ]; then
        wait $PID1 $PID2
    else
        wait $PID1
    fi

    log_success "Security audit complete. Results in: $RALPH_TMPDIR/"
}

cmd_bugs() {
    local TARGET
    TARGET=$(validate_path "$1")
    ensure_tmp

    log_info "Running bug hunting on: $TARGET"
    PID=$(run_codex_bugs "$TARGET")
    wait $PID
    log_success "Bug hunting complete."
    cat "$RALPH_TMPDIR/codex_bugs.json" 2>/dev/null | jq '.summary' || true
}

cmd_unit_tests() {
    local TARGET
    TARGET=$(validate_path "$1")
    ensure_tmp

    log_info "Generating unit tests for: $TARGET"
    PID=$(run_codex_unit_tests "$TARGET")
    wait $PID
    log_success "Unit test generation complete."
}

cmd_integration() {
    local TARGET
    TARGET=$(validate_path "$1")
    ensure_tmp

    log_info "Generating integration tests for: $TARGET"
    PID=$(run_gemini_integration "$TARGET")
    wait $PID
    log_success "Integration test generation complete."
}

cmd_refactor() {
    local TARGET
    TARGET=$(validate_path "$1")
    local SAFE_TARGET
    SAFE_TARGET=$(escape_for_shell "$TARGET")
    ensure_tmp

    log_info "Running refactoring analysis on: $TARGET"
    codex exec --yolo --enable-skills -m gpt-5.2-codex \
        "Refactor: ${SAFE_TARGET}
         Focus on: DRY, SOLID, extract methods, simplify conditionals.
         Output: refactored code + explanation" \
        > "$RALPH_TMPDIR/codex_refactor.json" 2>&1
    log_success "Refactoring analysis complete."
}

cmd_research() {
    local QUERY
    QUERY=$(validate_text_input "$1")
    local SAFE_QUERY
    SAFE_QUERY=$(escape_for_shell "$QUERY")
    ensure_tmp

    log_info "Researching: $QUERY"
    gemini "Research best practices and current solutions for: ${SAFE_QUERY}" \
        --yolo -o text > "$RALPH_TMPDIR/gemini_research.txt" 2>&1
    cat "$RALPH_TMPDIR/gemini_research.txt"
}

# ===============================================================================
# AST-GREP STRUCTURAL SEARCH (v2.23)
# ===============================================================================

cmd_ast() {
    # v2.23: Require ast-grep (sg) tool
    require_tool "sg" "structural code search"

    local PATTERN="${1:-}"
    local TARGET="${2:-.}"

    if [ -z "$PATTERN" ]; then
        echo ""
        echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
        echo "‚ïë  AST-GREP: Structural Code Search (v2.23)                     ‚ïë"
        echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
        echo "‚ïë                                                               ‚ïë"
        echo "‚ïë  Usage: ralph ast <pattern> [path]                            ‚ïë"
        echo "‚ïë                                                               ‚ïë"
        echo "‚ïë  Examples:                                                    ‚ïë"
        echo "‚ïë    ralph ast 'console.log(\$MSG)' src/                         ‚ïë"
        echo "‚ïë    ralph ast 'async function \$NAME' .                         ‚ïë"
        echo "‚ïë    ralph ast 'try { \$BODY } catch (\$E) {}' src/               ‚ïë"
        echo "‚ïë    ralph ast 'await \$EXPR' src/                               ‚ïë"
        echo "‚ïë                                                               ‚ïë"
        echo "‚ïë  Pattern Syntax:                                              ‚ïë"
        echo "‚ïë    \$VAR   - Match single node (variable, expression)          ‚ïë"
        echo "‚ïë    \$\$\$    - Match multiple nodes (statements, args)           ‚ïë"
        echo "‚ïë                                                               ‚ïë"
        echo "‚ïë  Supported Languages: TypeScript, Python, Go, Rust, Java, C++ ‚ïë"
        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
        exit 1
    fi

    # SECURITY: Validate pattern input (block control chars, limit length)
    local SAFE_PATTERN
    SAFE_PATTERN=$(validate_text_input "$PATTERN" 2000)

    # Validate path
    local SAFE_TARGET
    SAFE_TARGET=$(validate_path "$TARGET")

    log_info "AST Search: '$SAFE_PATTERN' in $SAFE_TARGET"
    sg --pattern "$SAFE_PATTERN" "$SAFE_TARGET"
}

# ===============================================================================
# GIT WORKTREE + PR WORKFLOW (v2.20)
# ===============================================================================
WORKTREES_DIR=".worktrees"

# Verify WorkTrunk is installed
check_worktruck() {
    if ! command -v wt &> /dev/null; then
        log_error "WorkTrunk (wt) is required for git worktree workflow."
        log_info "Install with: brew install max-sixty/worktrunk/wt"
        log_info "Then run: wt config shell install && source ~/.zshrc"
        return 1
    fi
    return 0
}

# Create isolated worktree for a feature/task
cmd_worktree() {
    # v2.22: Require wt tool
    require_tool "wt" "git worktree workflow"

    local TASK
    TASK=$(validate_text_input "${1:-}")

    if [ -z "$TASK" ]; then
        log_error "Usage: ralph worktree <task-description>"
        log_info "Example: ralph worktree 'implement oauth authentication'"
        return 1
    fi

    check_worktruck || return 1

    # Generate branch name from task
    local SANITIZED_TASK
    SANITIZED_TASK=$(echo "$TASK" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | cut -c1-40)
    local BRANCH_NAME="ai/ralph/$(date +%Y%m%d)-${SANITIZED_TASK}"

    log_info "Creating worktree for: $TASK"
    log_info "   Branch: $BRANCH_NAME"
    log_info "   Location: $WORKTREES_DIR/"

    # Ensure .worktrees directory exists
    mkdir -p "$WORKTREES_DIR"

    # Create worktree using WorkTrunk
    if ! wt switch -c "$BRANCH_NAME"; then
        log_error "Failed to create worktree"
        return 1
    fi

    # Get the worktree path
    local WT_PATH
    WT_PATH=$(git worktree list | grep "$BRANCH_NAME" | awk '{print $1}')

    if [ -z "$WT_PATH" ]; then
        log_error "Worktree created but path not found"
        return 1
    fi

    # Apply security hardening
    log_info "   Applying security hardening..."
    (
        cd "$WT_PATH" || exit 1
        git config --worktree core.hooksPath ".git-hooks-disabled" 2>/dev/null || true
        git config --worktree credential.helper "" 2>/dev/null || true
        git config --worktree push.default current 2>/dev/null || true
    )

    log_success "Worktree created: $WT_PATH"
    echo ""
    log_info "To launch Claude in this worktree:"
    echo "   cd $WT_PATH && claude"
    echo ""
    log_info "When done, create PR with:"
    echo "   ralph worktree-pr $BRANCH_NAME"
}

# Create PR with multi-agent review
cmd_worktree_pr() {
    # v2.22: Require wt and gh tools
    require_tools "PR workflow" "wt" "gh"

    local BRANCH="${1:-}"

    if [ -z "$BRANCH" ]; then
        # Try to get current branch
        BRANCH=$(git branch --show-current 2>/dev/null || echo "")
        if [ -z "$BRANCH" ] || [[ ! "$BRANCH" =~ ^ai/ralph/ ]]; then
            log_error "Usage: ralph worktree-pr <branch>"
            log_info "Example: ralph worktree-pr ai/ralph/20260103-oauth-feature"
            log_info ""
            log_info "Available worktrees:"
            git worktree list 2>/dev/null | grep -v "bare" || echo "  None found"
            return 1
        fi
    fi

    check_worktruck || return 1

    # Verify gh is installed
    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required for PR workflow."
        log_info "Install with: brew install gh && gh auth login"
        return 1
    fi

    log_info "Creating PR for branch: $BRANCH"

    # Switch to branch
    log_info "   Switching to worktree..."
    wt switch "$BRANCH" 2>/dev/null || git checkout "$BRANCH"

    # Push to remote
    log_info "   Pushing to origin..."
    if ! git push -u origin "$BRANCH" 2>/dev/null; then
        log_warn "   Push failed (may already exist or no changes)"
    fi

    # Generate PR title from branch name
    local PR_TITLE
    PR_TITLE=$(echo "$BRANCH" | sed 's|ai/ralph/[0-9]*-||' | tr '-' ' ')

    # Create PR draft
    log_info "   Creating draft PR..."
    local PR_URL
    if PR_URL=$(gh pr create --draft \
        --title "feat: ${PR_TITLE}" \
        --body "## Summary

Auto-generated PR from worktree workflow.

## Branch
\`$BRANCH\`

## Review

Multi-agent review will be posted as comments.

---
ü§ñ Generated by ralph worktree-pr" 2>&1); then
        log_success "PR created: $PR_URL"
    else
        log_error "Failed to create PR: $PR_URL"
        return 1
    fi

    # Get PR number
    local PR_NUMBER
    PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

    if [ -z "$PR_NUMBER" ]; then
        log_warn "Could not extract PR number, skipping reviews"
        return 0
    fi

    # Multi-agent review
    log_info "   Starting multi-agent code review..."
    ensure_tmp

    # Get diff for review
    local DIFF_FILE="$RALPH_TMPDIR/pr_diff.txt"
    gh pr diff "$PR_NUMBER" > "$DIFF_FILE" 2>/dev/null || git diff main..."$BRANCH" > "$DIFF_FILE"

    # Claude Opus Review
    log_info "   [1/2] Claude Opus reviewing..."
    local CLAUDE_REVIEW
    CLAUDE_REVIEW=$(cat "$DIFF_FILE" | claude --print -m opus -p "Review this code diff for:
- Logic errors and edge cases
- Code quality and maintainability
- Potential bugs
- Best practices violations

Output format:
## Claude Opus Review

### Summary
[Brief summary]

### Issues Found
[List any BLOCKER, CRITICAL, HIGH, MEDIUM, LOW issues]

### Recommendations
[Suggestions for improvement]

If no major issues: 'APPROVED ‚úÖ'
If blocking issues: 'BLOCKED ‚ùå - [reason]'" 2>&1 || echo "Claude review failed")

    # Post Claude review as comment
    if [ -n "$CLAUDE_REVIEW" ] && [ "$CLAUDE_REVIEW" != "Claude review failed" ]; then
        gh pr comment "$PR_NUMBER" --body "$CLAUDE_REVIEW" 2>/dev/null || log_warn "Failed to post Claude review"
        log_success "   Claude review posted"
    fi

    # Codex GPT-5 Review
    log_info "   [2/2] Codex GPT-5 reviewing..."
    local CODEX_REVIEW
    if command -v codex &> /dev/null; then
        CODEX_REVIEW=$(codex exec -m gpt-5 --reasoning high -C "$(pwd)" \
            "Review this code diff for security vulnerabilities, performance issues, and best practices.
             Diff file: $DIFF_FILE

             Output format:
             ## Codex GPT-5 Security Review

             ### Security Analysis
             [Security findings]

             ### Performance Analysis
             [Performance findings]

             ### Verdict
             'APPROVED ‚úÖ' or 'BLOCKED ‚ùå - [reason]'" 2>&1 || echo "Codex review failed")

        if [ -n "$CODEX_REVIEW" ] && [ "$CODEX_REVIEW" != "Codex review failed" ]; then
            gh pr comment "$PR_NUMBER" --body "$CODEX_REVIEW" 2>/dev/null || log_warn "Failed to post Codex review"
            log_success "   Codex review posted"
        fi
    else
        log_warn "   Codex not available, skipping security review"
    fi

    # Analyze results
    echo ""
    echo "==============================================================="
    echo "  PR REVIEW SUMMARY"
    echo "==============================================================="
    echo ""
    echo "  PR: $PR_URL"
    echo "  Branch: $BRANCH"
    echo ""

    # Check for blockers
    local HAS_BLOCKER=false
    if echo "$CLAUDE_REVIEW" | grep -qiE "(BLOCKED|BLOCKER|CRITICAL)"; then
        HAS_BLOCKER=true
        log_warn "  Claude found blocking issues"
    else
        log_success "  Claude: APPROVED"
    fi

    if echo "$CODEX_REVIEW" | grep -qiE "(BLOCKED|BLOCKER|CRITICAL)"; then
        HAS_BLOCKER=true
        log_warn "  Codex found blocking issues"
    else
        log_success "  Codex: APPROVED"
    fi

    echo ""
    echo "  Next steps:"
    if [ "$HAS_BLOCKER" = true ]; then
        log_warn "  Reviews found issues. Options:"
        echo "    ralph worktree-fix $PR_NUMBER    # Apply fixes from review"
        echo "    ralph worktree-close $PR_NUMBER  # Close and abandon"
    else
        log_success "  All reviews passed! Options:"
        echo "    ralph worktree-merge $PR_NUMBER  # Merge PR"
        echo "    ralph worktree-fix $PR_NUMBER    # Make additional changes"
    fi
    echo "==============================================================="
}

# Merge approved PR and cleanup
cmd_worktree_merge() {
    local PR_NUMBER="${1:-}"

    if [ -z "$PR_NUMBER" ]; then
        log_error "Usage: ralph worktree-merge <pr-number>"
        log_info "Example: ralph worktree-merge 123"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required."
        return 1
    fi

    log_info "Merging PR #$PR_NUMBER..."

    # Mark PR ready for review
    log_info "   Marking PR as ready..."
    gh pr ready "$PR_NUMBER" 2>/dev/null || log_warn "PR may already be ready"

    # Wait for CI checks
    log_info "   Waiting for CI checks..."
    if ! gh pr checks "$PR_NUMBER" --watch 2>/dev/null; then
        log_warn "   CI checks may have issues, proceeding..."
    fi

    # Merge with squash
    log_info "   Merging with squash..."
    if gh pr merge "$PR_NUMBER" --squash --delete-branch; then
        log_success "PR #$PR_NUMBER merged!"

        # Cleanup worktree
        log_info "   Cleaning up worktree..."
        local BRANCH
        BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName -q '.headRefName' 2>/dev/null || echo "")
        if [ -n "$BRANCH" ]; then
            wt remove "$BRANCH" 2>/dev/null || git worktree remove "$BRANCH" 2>/dev/null || true
            git branch -d "$BRANCH" 2>/dev/null || true
        fi
        git worktree prune 2>/dev/null || true

        log_success "Worktree cleanup complete"
    else
        log_error "Failed to merge PR #$PR_NUMBER"
        return 1
    fi
}

# Apply fixes based on review comments
cmd_worktree_fix() {
    local PR_NUMBER="${1:-}"

    if [ -z "$PR_NUMBER" ]; then
        log_error "Usage: ralph worktree-fix <pr-number>"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required."
        return 1
    fi

    log_info "Fetching review comments for PR #$PR_NUMBER..."

    # Get PR branch
    local BRANCH
    BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName -q '.headRefName' 2>/dev/null)

    if [ -z "$BRANCH" ]; then
        log_error "Could not find branch for PR #$PR_NUMBER"
        return 1
    fi

    # Switch to branch
    log_info "   Switching to: $BRANCH"
    wt switch "$BRANCH" 2>/dev/null || git checkout "$BRANCH"

    # Get comments
    local COMMENTS
    COMMENTS=$(gh pr view "$PR_NUMBER" --comments 2>/dev/null || echo "No comments found")

    echo ""
    echo "==============================================================="
    echo "  REVIEW COMMENTS FOR PR #$PR_NUMBER"
    echo "==============================================================="
    echo "$COMMENTS" | head -100
    echo "==============================================================="
    echo ""
    log_info "To apply fixes:"
    echo "   1. Review the comments above"
    echo "   2. Make necessary changes"
    echo "   3. Commit: git commit -am 'fix: address review comments'"
    echo "   4. Push: git push"
    echo "   5. Re-run review: ralph worktree-pr $BRANCH"
}

# Close PR and cleanup without merging
cmd_worktree_close() {
    local PR_NUMBER="${1:-}"

    if [ -z "$PR_NUMBER" ]; then
        log_error "Usage: ralph worktree-close <pr-number>"
        return 1
    fi

    if ! command -v gh &> /dev/null; then
        log_error "GitHub CLI (gh) is required."
        return 1
    fi

    log_warn "Closing PR #$PR_NUMBER without merging..."

    # Get branch before closing
    local BRANCH
    BRANCH=$(gh pr view "$PR_NUMBER" --json headRefName -q '.headRefName' 2>/dev/null || echo "")

    # Close PR
    gh pr close "$PR_NUMBER" --delete-branch 2>/dev/null || gh pr close "$PR_NUMBER"

    # Cleanup worktree
    if [ -n "$BRANCH" ]; then
        log_info "   Cleaning up worktree: $BRANCH"
        wt remove "$BRANCH" 2>/dev/null || git worktree remove "$BRANCH" 2>/dev/null || true
        git branch -D "$BRANCH" 2>/dev/null || true
    fi
    git worktree prune 2>/dev/null || true

    log_success "PR #$PR_NUMBER closed and cleaned up"
}

# Show status of all worktrees
cmd_worktree_status() {
    log_info "Git Worktree Status:"
    echo ""

    if command -v wt &> /dev/null; then
        wt list 2>/dev/null || git worktree list
    else
        git worktree list
    fi

    echo ""
    log_info "Active PRs from worktrees:"
    if command -v gh &> /dev/null; then
        gh pr list --author "@me" --json number,title,headRefName,state \
            --jq '.[] | select(.headRefName | startswith("ai/ralph")) | "  #\(.number) [\(.state)] \(.title)"' 2>/dev/null || echo "  None found"
    else
        echo "  (install gh for PR status)"
    fi
}

# Cleanup merged worktrees
cmd_worktree_cleanup() {
    log_info "Cleaning up merged worktrees..."

    # Find merged ai/ralph branches
    local MERGED_BRANCHES
    MERGED_BRANCHES=$(git branch --merged main 2>/dev/null | grep "ai/ralph" || echo "")

    if [ -z "$MERGED_BRANCHES" ]; then
        log_info "No merged ai/ralph branches found"
    else
        echo "$MERGED_BRANCHES" | while read -r branch; do
            branch=$(echo "$branch" | tr -d ' *')
            if [ -n "$branch" ]; then
                log_info "   Removing: $branch"
                wt remove "$branch" 2>/dev/null || git worktree remove "$branch" 2>/dev/null || true
                git branch -d "$branch" 2>/dev/null || true
            fi
        done
    fi

    # Prune worktree metadata
    git worktree prune 2>/dev/null || true

    # Clean .worktrees directory if empty
    if [ -d "$WORKTREES_DIR" ] && [ -z "$(ls -A "$WORKTREES_DIR" 2>/dev/null)" ]; then
        rmdir "$WORKTREES_DIR" 2>/dev/null || true
    fi

    log_success "Cleanup complete"
    cmd_worktree_status
}

# ===============================================================================
# MAINTENANCE COMMANDS (v2.21)
# ===============================================================================

# Self-update: sync scripts from repo to ~/.local/bin/
cmd_self_update() {
    local REPO_PATH=""
    local INSTALL_DIR="${HOME}/.local/bin"

    # Try to find ralph repo
    if [ -f "./scripts/ralph" ] && grep -q "Multi-Agent Orchestrator" "./scripts/ralph" 2>/dev/null; then
        REPO_PATH="$(pwd)"
    elif [ -f "../multi-agent-ralph-loop/scripts/ralph" ]; then
        REPO_PATH="$(cd ../multi-agent-ralph-loop && pwd)"
    elif [ -d "${HOME}/Documents/GitHub/multi-agent-ralph-loop" ]; then
        REPO_PATH="${HOME}/Documents/GitHub/multi-agent-ralph-loop"
    fi

    if [ -z "$REPO_PATH" ] || [ ! -f "$REPO_PATH/scripts/ralph" ]; then
        log_error "Cannot find ralph repository."
        log_info "Options:"
        echo "  1. cd to the ralph repo and run: ralph self-update"
        echo "  2. Clone repo: git clone https://github.com/yourrepo/multi-agent-ralph-loop"
        return 1
    fi

    log_info "Syncing scripts from: $REPO_PATH"

    # Get versions
    local REPO_VERSION
    local INSTALLED_VERSION
    REPO_VERSION=$(grep "^VERSION=" "$REPO_PATH/scripts/ralph" | cut -d'"' -f2)
    INSTALLED_VERSION="$VERSION"

    log_info "   Installed: v$INSTALLED_VERSION"
    log_info "   Repo:      v$REPO_VERSION"

    if [ "$REPO_VERSION" = "$INSTALLED_VERSION" ]; then
        log_success "Already up to date (v$INSTALLED_VERSION)"
        return 0
    fi

    # Create backup
    if [ -f "$INSTALL_DIR/ralph" ]; then
        cp "$INSTALL_DIR/ralph" "$INSTALL_DIR/ralph.bak.$(date +%Y%m%d_%H%M%S)"
        log_info "   Backup created"
    fi

    # Copy scripts
    mkdir -p "$INSTALL_DIR"
    cp "$REPO_PATH/scripts/ralph" "$INSTALL_DIR/ralph"
    chmod +x "$INSTALL_DIR/ralph"
    log_success "   Updated: ralph"

    if [ -f "$REPO_PATH/scripts/mmc" ]; then
        cp "$REPO_PATH/scripts/mmc" "$INSTALL_DIR/mmc"
        chmod +x "$INSTALL_DIR/mmc"
        log_success "   Updated: mmc"
    fi

    log_success "Updated to v$REPO_VERSION"
    log_info "Restart your shell or run: source ~/.zshrc"
}

# Pre-merge validation: run before creating a PR
cmd_pre_merge() {
    local ERRORS=0

    echo ""
    echo "==============================================================="
    echo "  PRE-MERGE VALIDATION"
    echo "==============================================================="
    echo ""

    # 1. Shellcheck
    log_info "[1/4] Running shellcheck on scripts..."
    if command -v shellcheck &> /dev/null; then
        local SCRIPTS=("scripts/ralph" "scripts/mmc" "install.sh" "uninstall.sh")
        for script in "${SCRIPTS[@]}"; do
            if [ -f "$script" ]; then
                if shellcheck -S error "$script" 2>/dev/null; then
                    log_success "   $script: OK"
                else
                    log_error "   $script: FAILED"
                    ((ERRORS++)) || true
                fi
            fi
        done
    else
        log_warn "   shellcheck not installed (brew install shellcheck)"
    fi

    # 2. Version synchronization
    log_info "[2/4] Checking version synchronization..."
    local VERSIONS=()
    [ -f "scripts/ralph" ] && VERSIONS+=("ralph:$(grep "^VERSION=" scripts/ralph 2>/dev/null | cut -d'"' -f2)")
    [ -f "scripts/mmc" ] && VERSIONS+=("mmc:$(grep "^VERSION=" scripts/mmc 2>/dev/null | cut -d'"' -f2)")
    [ -f "install.sh" ] && VERSIONS+=("install:$(grep "^VERSION=" install.sh 2>/dev/null | cut -d'"' -f2)")
    [ -f "uninstall.sh" ] && VERSIONS+=("uninstall:$(grep "^VERSION=" uninstall.sh 2>/dev/null | cut -d'"' -f2)")

    local FIRST_VERSION=""
    local ALL_MATCH=true
    for v in "${VERSIONS[@]}"; do
        local name="${v%%:*}"
        local ver="${v##*:}"
        echo "   $name: $ver"
        if [ -z "$FIRST_VERSION" ]; then
            FIRST_VERSION="$ver"
        elif [ "$ver" != "$FIRST_VERSION" ]; then
            ALL_MATCH=false
        fi
    done

    if [ "$ALL_MATCH" = true ]; then
        log_success "   All versions match: $FIRST_VERSION"
    else
        log_error "   Version mismatch detected!"
        ((ERRORS++)) || true
    fi

    # 3. Run tests
    log_info "[3/4] Running tests..."
    if [ -d "tests" ] && command -v bats &> /dev/null; then
        if bats tests/*.bats > /dev/null 2>&1; then
            local TEST_COUNT
            TEST_COUNT=$(bats tests/*.bats 2>&1 | grep -cE "^ok " || echo "0")
            log_success "   All $TEST_COUNT tests passed"
        else
            log_error "   Some tests failed"
            ((ERRORS++)) || true
        fi
    else
        log_warn "   Tests skipped (bats not installed or no tests/ dir)"
    fi

    # 4. Git status
    log_info "[4/4] Checking git status..."
    local UNCOMMITTED
    UNCOMMITTED=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$UNCOMMITTED" -gt 0 ]; then
        log_warn "   $UNCOMMITTED uncommitted changes"
        git status --short 2>/dev/null | head -10
    else
        log_success "   Working tree clean"
    fi

    echo ""
    echo "==============================================================="
    if [ $ERRORS -eq 0 ]; then
        log_success "  PRE-MERGE VALIDATION PASSED"
        echo ""
        echo "  Ready to create PR:"
        echo "    git push -u origin \$(git branch --show-current)"
        echo "    gh pr create --title 'feat: ...' --body '...'"
    else
        log_error "  PRE-MERGE VALIDATION FAILED ($ERRORS errors)"
        echo ""
        echo "  Fix the issues above before creating a PR."
    fi
    echo "==============================================================="

    return $ERRORS
}

# Integrations health check: show status of all tools (Greptile is OPTIONAL)
cmd_integrations() {
    echo ""
    echo "==============================================================="
    echo "  RALPH INTEGRATIONS STATUS"
    echo "==============================================================="
    echo ""

    # Core tools (REQUIRED)
    log_info "REQUIRED TOOLS:"

    # Claude CLI
    if command -v claude &> /dev/null; then
        local CLAUDE_VER
        CLAUDE_VER=$(claude --version 2>&1 | head -1 || echo "unknown")
        log_success "  Claude CLI:     $CLAUDE_VER"
    else
        log_error "  Claude CLI:     NOT INSTALLED"
    fi

    # GitHub CLI
    if command -v gh &> /dev/null; then
        local GH_VER
        GH_VER=$(gh --version 2>&1 | head -1 | awk '{print $3}')
        local GH_AUTH
        GH_AUTH=$(gh auth status 2>&1 | grep -q "Logged in" && echo "authenticated" || echo "not authenticated")
        log_success "  GitHub CLI:     v$GH_VER ($GH_AUTH)"
    else
        log_error "  GitHub CLI:     NOT INSTALLED (brew install gh)"
    fi

    # WorkTrunk
    if command -v wt &> /dev/null; then
        log_success "  WorkTrunk:      installed"
    else
        log_error "  WorkTrunk:      NOT INSTALLED (brew install max-sixty/worktrunk/wt)"
    fi

    # Git
    if command -v git &> /dev/null; then
        local GIT_VER
        GIT_VER=$(git --version | awk '{print $3}')
        log_success "  Git:            v$GIT_VER"
    else
        log_error "  Git:            NOT INSTALLED"
    fi

    echo ""
    log_info "OPTIONAL AI TOOLS:"

    # Codex CLI
    if command -v codex &> /dev/null; then
        local CODEX_VER
        CODEX_VER=$(codex --version 2>&1 | head -1 || echo "installed")
        log_success "  Codex CLI:      $CODEX_VER"
    else
        log_warn "  Codex CLI:      not installed (npm i -g @openai/codex)"
    fi

    # Gemini CLI
    if command -v gemini &> /dev/null; then
        log_success "  Gemini CLI:     installed"
    else
        log_warn "  Gemini CLI:     not installed"
    fi

    # MiniMax (mmc)
    if command -v mmc &> /dev/null; then
        local MMC_VER
        MMC_VER=$(mmc --version 2>&1 | head -1 || echo "installed")
        log_success "  MiniMax (mmc):  $MMC_VER"
    else
        log_warn "  MiniMax (mmc):  not installed"
    fi

    echo ""
    log_info "OPTIONAL SERVICES (no cost requirement):"

    # Greptile - ALWAYS OPTIONAL
    if command -v greptile &> /dev/null || [ -n "${GREPTILE_API_KEY:-}" ]; then
        log_success "  Greptile:       configured (OPTIONAL)"
    else
        log_info "  Greptile:       not configured (OPTIONAL - greptile.com/open-source for free tier)"
    fi

    echo ""
    log_info "DEVELOPMENT TOOLS:"

    # Shellcheck
    if command -v shellcheck &> /dev/null; then
        local SC_VER
        SC_VER=$(shellcheck --version 2>&1 | grep "version:" | awk '{print $2}')
        log_success "  shellcheck:     v$SC_VER"
    else
        log_warn "  shellcheck:     not installed (brew install shellcheck)"
    fi

    # Bats
    if command -v bats &> /dev/null; then
        local BATS_VER
        BATS_VER=$(bats --version 2>&1 | awk '{print $2}')
        log_success "  bats:           v$BATS_VER"
    else
        log_warn "  bats:           not installed (brew install bats-core)"
    fi

    # jq
    if command -v jq &> /dev/null; then
        local JQ_VER
        JQ_VER=$(jq --version 2>&1)
        log_success "  jq:             $JQ_VER"
    else
        log_warn "  jq:             not installed (brew install jq)"
    fi

    echo ""
    echo "==============================================================="
    echo "  Note: Greptile is always OPTIONAL. No paid tools required."
    echo "==============================================================="
}

cmd_minimax() {
    # v2.22: Require mmc tool
    require_tool "mmc" "MiniMax second opinion"

    local QUERY
    QUERY=$(validate_text_input "$1")
    local SAFE_QUERY
    SAFE_QUERY=$(escape_for_shell "$QUERY")

    # Check for MiniMax config: primary path, then legacy fallback
    local MINIMAX_CONFIG=""
    if [ -f "${CONFIG_DIR}/minimax.json" ]; then
        MINIMAX_CONFIG="${CONFIG_DIR}/minimax.json"
    elif [ -f "${RALPH_DIR}/config/minimax.json" ]; then
        MINIMAX_CONFIG="${RALPH_DIR}/config/minimax.json"
    elif [ -f "${HOME}/.mmc.json" ]; then
        MINIMAX_CONFIG="${HOME}/.mmc.json"  # Legacy fallback
    fi

    if ! command -v mmc &> /dev/null || [ -z "$MINIMAX_CONFIG" ]; then
        log_error "MiniMax not configured."
        log_info "   Expected config at: ${CONFIG_DIR}/minimax.json"
        log_info "   Or legacy path: ~/.mmc.json"
        log_info "   Run: mmc --setup"
        return 1
    fi

    log_info "Querying MiniMax M2.1..."
    mmc --query "${SAFE_QUERY}"
}

cmd_clarify() {
    local TASK
    TASK=$(validate_text_input "$1")
    local SAFE_TASK
    SAFE_TASK=$(escape_for_shell "$TASK")

    log_info "Generating clarification questions for: $TASK"
    echo ""

    # Use Claude with the skill
    claude --print -p "Use the ask-questions-if-underspecified skill.

                       Task: ${SAFE_TASK}

                       Generate MUST_HAVE and NICE_TO_HAVE questions."
}

# ===============================================================================
# LOOP COMMAND
# ===============================================================================
cmd_loop() {
    local TASK
    TASK=$(validate_text_input "$1")
    local USE_MINIMAX="${2:-false}"
    local MAX_ITER=$CLAUDE_MAX_ITER
    local SAFE_TASK
    SAFE_TASK=$(escape_for_shell "$TASK")

    if [ "$USE_MINIMAX" = "--mmc" ] || [ "$USE_MINIMAX" = "--minimax" ]; then
        MAX_ITER=$MINIMAX_MAX_ITER
        log_info "Starting Ralph loop with MiniMax ($MAX_ITER iterations max)"
    elif [ "$USE_MINIMAX" = "--lightning" ]; then
        MAX_ITER=$LIGHTNING_MAX_ITER
        log_info "Starting Ralph loop with Lightning ($MAX_ITER iterations max)"
    else
        log_info "Starting Ralph loop with Claude ($MAX_ITER iterations max)"
    fi

    log_info "   Task: $TASK"
    echo ""

    local ITER=0
    while [ $ITER -lt $MAX_ITER ]; do
        ((ITER++))
        log_info "  Iteration $ITER/$MAX_ITER"

        # Execute task
        if [ "$USE_MINIMAX" = "--mmc" ] || [ "$USE_MINIMAX" = "--minimax" ]; then
            RESULT=$(mmc --query "${SAFE_TASK}. Check if complete, output VERIFIED_DONE if done." 2>&1)
        else
            RESULT=$(claude --print -p "${SAFE_TASK}. Check if complete, output VERIFIED_DONE if done." 2>&1)
        fi

        # Check for completion
        if echo "$RESULT" | grep -q "VERIFIED_DONE"; then
            log_success "Task completed at iteration $ITER"
            return 0
        fi
    done

    log_warn "Max iterations ($MAX_ITER) reached without VERIFIED_DONE"
    return 1
}

# ===============================================================================
# SELF-IMPROVEMENT COMMANDS
# ===============================================================================
cmd_retrospective() {
    ensure_dirs

    log_info "Running retrospective analysis..."
    echo ""

    # Detect if we're in the ralph-loop repo (for direct improvement commits)
    local REPO_DIR=""
    local OUTPUT_FILE=""

    if [ -f "./CLAUDE.md" ] && grep -q "Multi-Agent Ralph" "./CLAUDE.md" 2>/dev/null; then
        REPO_DIR="$(pwd)"
        OUTPUT_FILE="${REPO_DIR}/tests/RETROSPECTIVE.md"
        log_info "Detected ralph-loop repo: improvements will be saved to ${OUTPUT_FILE}"
    elif git remote -v 2>/dev/null | grep -q "multi-agent-ralph"; then
        REPO_DIR="$(git rev-parse --show-toplevel 2>/dev/null)"
        OUTPUT_FILE="${REPO_DIR}/tests/RETROSPECTIVE.md"
        log_info "Detected ralph-loop repo: improvements will be saved to ${OUTPUT_FILE}"
    fi

    local RETRO_OUTPUT
    RETRO_OUTPUT=$(claude --print -p "Use the retrospective skill.

                       Analyze the last task completed and propose improvements to the Ralph Wiggum system.

                       Categories to analyze:
                       1. Routing effectiveness (was complexity accurate?)
                       2. Clarification quality (right questions asked?)
                       3. Agent performance (which were useful?)
                       4. Quality gate effectiveness
                       5. Iteration efficiency

                       Output improvement proposals with:
                       - Type (routing_adjustment, clarification_enhancement, agent_behavior, new_command, delegation_update, quality_gate)
                       - File to modify (use paths relative to the repo root)
                       - Specific change
                       - Justification
                       - Risk level

                       IMPORTANT: Format output as a complete RETROSPECTIVE.md file with:
                       - Date header
                       - Task summary
                       - What went well
                       - Improvement opportunities
                       - Proposed changes in JSON format")

    echo "$RETRO_OUTPUT"

    # Save to repo if detected
    if [ -n "$OUTPUT_FILE" ]; then
        mkdir -p "$(dirname "$OUTPUT_FILE")"
        echo "$RETRO_OUTPUT" > "$OUTPUT_FILE"
        echo ""
        log_success "Retrospective saved to: $OUTPUT_FILE"
        echo ""
        log_info "To commit improvements:"
        echo "  git add tests/RETROSPECTIVE.md"
        echo "  git commit -m 'docs(retro): Add retrospective for [task description]'"
        echo "  git push origin main"
    else
        # Save to global improvements dir as fallback
        mkdir -p "$IMPROVEMENTS_DIR"
        echo "$RETRO_OUTPUT" > "$IMPROVEMENTS_DIR/pending.md"
        log_info "Saved to: $IMPROVEMENTS_DIR/pending.md"
        log_info "Use 'ralph improvements' to review"
    fi
}

cmd_improvements() {
    ensure_dirs
    local ACTION="${1:-list}"

    case "$ACTION" in
        list|"")
            log_info "Pending improvements:"
            if [ -f "$IMPROVEMENTS_DIR/pending.md" ] && [ -s "$IMPROVEMENTS_DIR/pending.md" ]; then
                cat "$IMPROVEMENTS_DIR/pending.md"
            else
                echo "  No pending improvements."
            fi
            ;;
        apply)
            shift
            local IDS="${1:-all}"
            log_info "Applying improvements: $IDS"
            # Create backup first
            cp -r "${HOME}/.claude" "$IMPROVEMENTS_DIR/backups/.claude-$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
            log_success "Backup created. Implement apply logic here."
            ;;
        reject)
            shift
            local IDS="${1:-all}"
            log_info "Rejecting improvements: $IDS"
            ;;
        *)
            log_error "Unknown action: $ACTION. Use: list, apply, reject"
            ;;
    esac
}

# ===============================================================================
# ORCHESTRATION
# ===============================================================================
cmd_orch() {
    local TASK
    TASK=$(validate_text_input "$1")
    local SAFE_TASK
    SAFE_TASK=$(escape_for_shell "$TASK")

    echo ""
    echo "==============================================================="
    echo "  RALPH WIGGUM v2.21 ORCHESTRATION"
    echo "==============================================================="
    echo ""
    echo "  NOTE: v2.21 adds self-update, pre-merge validation, and integrations check."
    echo "        Uses AskUserQuestion and EnterPlanMode."
    echo ""
    echo "  For best experience, use the Claude Code /orchestrator command"
    echo "  which provides native interactive questioning."
    echo ""
    echo "==============================================================="
    echo ""

    # Step 0: Auto-Plan Mode (inform user)
    log_info "[0/7] AUTO-PLAN MODE"
    log_info "   Non-trivial tasks automatically enter Plan Mode in Claude Code"
    echo ""

    # Step 1: Clarify (legacy CLI mode)
    log_info "[1/7] CLARIFY"
    log_info "   Generating clarification questions..."
    cmd_clarify "$TASK"
    echo ""
    log_warn "   For interactive questioning, use: claude then /orchestrator"
    read -p "Press Enter to continue after reviewing questions (or Ctrl+C to abort)..."

    # Step 2: Classify
    log_info "[2/7] CLASSIFY"
    claude --print -p "Use task-classifier skill. Classify complexity (1-10) for: ${SAFE_TASK}"
    echo ""

    # Step 3: Plan
    log_info "[3/7] PLAN"
    log_info "   In Claude Code, this step writes a detailed plan for approval"
    echo ""

    # Step 4: Delegate
    log_info "[4/7] DELEGATE"
    log_info "   Launching appropriate subagents..."

    # Step 5: Execute
    log_info "[5/7] EXECUTE"
    cmd_parallel . false

    # Step 6: Validate
    log_info "[6/7] VALIDATE"
    cmd_gates --check

    # Step 7: Retrospective
    log_info "[7/7] RETROSPECTIVE"
    cmd_retrospective

    echo ""
    echo "==============================================================="
    log_success "  ORCHESTRATION COMPLETE"
    echo "==============================================================="
}

# ===============================================================================
# UNINSTALL
# ===============================================================================
cmd_uninstall() {
    local UNINSTALL_SCRIPT="${RALPH_DIR}/../.local/share/ralph/uninstall.sh"

    # Try multiple locations
    if [ -f "./uninstall.sh" ]; then
        exec ./uninstall.sh "$@"
    elif [ -f "${HOME}/.ralph/uninstall.sh" ]; then
        exec "${HOME}/.ralph/uninstall.sh" "$@"
    else
        log_error "Uninstall script not found."
        log_info "Download from: https://github.com/yourrepo/multi-agent-ralph-loop"
        echo ""
        echo "Manual uninstall:"
        echo "  rm -f ~/.local/bin/ralph ~/.local/bin/mmc"
        echo "  rm -rf ~/.ralph"
        echo "  # Remove ralph sections from ~/.zshrc or ~/.bashrc"
        return 1
    fi
}

# ===============================================================================
# MAIN
# ===============================================================================
main() {
    local CMD="${1:-help}"
    shift || true

    # v2.22: Startup validation (skip for instant commands)
    case "$CMD" in
        help|-h|--help|version|-v|--version|status) ;;
        *) startup_validation ;;
    esac

    case "$CMD" in
        # Orchestration
        orch|orchestrate)
            cmd_orch "$@"
            ;;
        loop)
            cmd_loop "$@"
            ;;
        clarify)
            cmd_clarify "$@"
            ;;

        # Review
        review|full-review)
            cmd_parallel "$@"
            ;;
        parallel)
            cmd_parallel "$@"
            ;;

        # Specialized
        security)
            cmd_security "$@"
            ;;
        bugs)
            cmd_bugs "$@"
            ;;
        unit-tests|tests)
            cmd_unit_tests "$@"
            ;;
        integration)
            cmd_integration "$@"
            ;;
        refactor)
            cmd_refactor "$@"
            ;;
        research)
            cmd_research "$@"
            ;;
        minimax|mm)
            cmd_minimax "$@"
            ;;

        # Validation
        gates)
            cmd_gates "$@"
            ;;
        adversarial|adv)
            cmd_adversarial "$@"
            ;;

        # Self-improvement
        retrospective|retro)
            cmd_retrospective
            ;;
        improvements|improve)
            cmd_improvements "$@"
            ;;

        # Git Worktree + PR Workflow (v2.20)
        worktree)
            cmd_worktree "$@"
            ;;
        worktree-pr)
            cmd_worktree_pr "$@"
            ;;
        worktree-merge)
            cmd_worktree_merge "$@"
            ;;
        worktree-fix)
            cmd_worktree_fix "$@"
            ;;
        worktree-close)
            cmd_worktree_close "$@"
            ;;
        worktree-status|wt-status)
            cmd_worktree_status
            ;;
        worktree-cleanup|wt-cleanup)
            cmd_worktree_cleanup
            ;;

        # Maintenance (v2.21)
        self-update|update)
            cmd_self_update
            ;;
        pre-merge|premerge)
            cmd_pre_merge
            ;;
        integrations|int)
            cmd_integrations
            ;;

        # Search (v2.23)
        ast|ast-grep)
            cmd_ast "$@"
            ;;

        # Utility
        status)
            log_info "Active ralph processes:"
            ps aux | grep -E "(codex|gemini|mmc|ralph)" | grep -v grep || echo "  None"
            ;;
        version|-v|--version)
            echo "ralph v$VERSION"
            ;;
        help|-h|--help)
            show_help
            ;;
        --uninstall|uninstall)
            cmd_uninstall "$@"
            ;;
        *)
            log_error "Unknown command: $CMD"
            echo "Run 'ralph help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
